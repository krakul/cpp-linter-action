{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"C/C++ Lint Action | clang-format & clang-tidy \u00b6 A Github Action for linting C/C++ code integrating clang-tidy and clang-format to collect feedback provided in the form of thread comments and/or annotations. Usage \u00b6 Create a new GitHub Actions workflow in your project, e.g. at .github/workflows/cpp-linter.yml The content of the file should be in the following format. # Workflow syntax: # https://help.github.com/en/articles/workflow-syntax-for-github-actions name : cpp-linter on : pull_request : types : [ opened , reopened ] # let PR-synchronize events be handled by push events push : jobs : cpp-linter : runs-on : ubuntu-latest steps : - uses : actions/checkout@v3 - uses : cpp-linter/cpp-linter-action@v1 id : linter env : GITHUB_TOKEN : ${{ secrets.GITHUB_TOKEN }} with : style : file - name : Fail fast?! if : steps.linter.outputs.checks-failed > 0 run : echo \"Some files failed the linting checks!\" # for actual deployment # run: exit 1 Optional Inputs \u00b6 style \u00b6 Description : The style rules to use. Set this to 'file' to have clang-format use the closest relative .clang-format file. Set this to a blank string ( '' ) to disable the use of clang-format entirely. Default: 'llvm' extensions \u00b6 Description : The file extensions to run the action against. This is a comma-separated string. Default: 'c,h,C,H,cpp,hpp,cc,hh,c++,h++,cxx,hxx' tidy-checks \u00b6 Description : Comma-separated list of globs with optional - prefix. Globs are processed in order of appearance in the list. Globs without - prefix add checks with matching names to the set, globs with the - prefix remove checks with matching names from the set of enabled checks. This option's value is appended to the value of the 'Checks' option in a .clang-tidy file (if any). It is possible to disable clang-tidy entirely by setting this option to '-*' . It is also possible to rely solely on a .clang-tidy config file by specifying this option as a blank string ( '' ). Default: 'boost-*,bugprone-*,performance-*,readability-*,portability-*,modernize-*,clang-analyzer-*,cppcoreguidelines-*' repo-root \u00b6 Description : The relative path to the repository root directory. This path is relative to the path designated as the runner's GITHUB_WORKSPACE environment variable. Default: '.' version \u00b6 Description : The desired version of the clang-tools to use. Accepted options are strings which can be 14, 13, 12, 11, 10, 9, or 8. Set this option to a blank string ( '' ) to use the platform's default installed version. This value can also be a path to where the clang tools are installed (if using a custom install location). Because all paths specified here are converted to absolute, using a relative path as a value may not be compatible when using the docker environment (see Running without the docker container ). Default: '12' verbosity \u00b6 Description : This controls the action's verbosity in the workflow's logs. Supported options are defined by the python logging library's log levels . This option does not affect the verbosity of resulting thread comments or file annotations. Default: '10' lines-changed-only \u00b6 Description : This controls what part of the files are analyzed. The following values are accepted: false: All lines in a file are analyzed. true: Only lines in the diff that contain additions are analyzed. diff: All lines in the diff are analyzed (including unchanged lines but not subtractions). Default: false. files-changed-only \u00b6 Description : Set this option to false to analyze any source files in the repo. This is automatically enabled if lines-changed-only is enabled. Default: true NOTE: The GITHUB_TOKEN should be supplied when running on a private repository with this option enabled, otherwise the runner does not not have the privilege to list changed files for an event. See Authenticating with the GITHUB_TOKEN ignore \u00b6 Description : Set this option with string of path(s) to ignore. In the case of multiple paths, you can use a pipe character ( | ) to separate the multiple paths. Multiple lines are forbidden as an input to this option; it must be a single string. This can also have files, but the file's relative path has to be specified as well. There is no need to use ./ for each entry; a blank string ( '' ) represents the repo-root path (specified by the repo-root input option). Submodules are automatically ignored. Hidden directories (beginning with a . ) are also ignored automatically. Prefix a path with a bang ( ! ) to make it explicitly not ignored. The order of multiple paths does not take precedence. The ! prefix can be applied to a submodule's path (if desired) but not hidden directories. Glob patterns are not supported here. All asterisk characters ( * ) are literal. Default: '.github' thread-comments \u00b6 Description : Set this option to false to disable the use of thread comments as feedback. To use thread comments, the GITHUB_TOKEN (provided by Github to each repository) must be declared as an environment variable. See Authenticating with the GITHUB_TOKEN Default: false NOTE: If run on a private repository, then this feature is disabled because the GitHub REST API behaves differently for thread comments on a private repository. file-annotations \u00b6 Description : Set this option to false to disable the use of file annotations as feedback. Default: true database \u00b6 Description : The directory containing compilation database (like compile_commands.json) file. This option doesn't seems to work properly from the docker environment. Instead we recommend using this option when see running without the docker container . Default: '' Outputs \u00b6 This action creates 1 output variable named checks-failed . Even if the linting checks fail for source files this action will still pass, but users' CI workflows can use this action's output to exit the workflow early if that is desired. Running without the docker container \u00b6 Some Continuous Integration environments require access to non-default compilers and/or non-standard libraries. To do this properly, the docker container should not be used due to it's isolated file system. Instead, you should use this action's python source code as an installed python package (see below). Using the python source code \u00b6 This action was originally designed to only be used on a runner with the Ubuntu Operating System. However, this action's source code (essentially a python package) can be used on any runner using the Windows, Ubuntu, or possibly even MacOS (untested) virtual environments. Note, some runners already ship with clang-format and/or clang-tidy. As of this writing, the following versions of clang-format and clang-tidy are already available: ubuntu-latest ships with v10, v11, and v12. More details . windows-latest ships with v13. More details . macos-latest ships with v13. More details . This example makes use of another action ( KyleMayes/install-llvm-action ) to install a certain version of clang-tidy and clang-format. on: pull_request: types: [opened, reopened] # let PR-synchronize events be handled by push events push: jobs: cpp-linter: runs-on: windows-latest steps: - uses: actions/checkout@v3 - uses: actions/setup-python@v4 # this step can be skipped if the desired # version already comes with the runner's OS - name: Install clang-tools uses: KyleMayes/install-llvm-action@v1 with: # v13 is the recommended minimum for the Visual Studio compiler (on Windows) version: 14 # specifying an install path is required (on Windows) because installing # multiple versions on Windows runners needs non-default install paths. directory: ${{ runner.temp }}/llvm - name: Install linter python package run: python3 -m pip install git+https://github.com/cpp-linter/cpp-linter-action@v1 - name: run linter as a python package id: linter # Pass the installed path to the '--version' argument. # Alternatively, pass the version number. # Example. run: cpp-linter --version=14 # Omit the version option if using the default version available in the OS. run: cpp-linter --version=${{ runner.temp }}/llvm - name: Fail fast?! if: steps.linter.outputs.checks-failed > 0 run: echo \"Some files failed the linting checks!\" # for actual deployment # run: exit 1 All input options listed above are specified by pre-pending a -- . You can also install this repo locally and run cpp-linter -h for more detail. For example: - uses : cpp-linter/cpp-linter-action@v1 with : style : file tidy-checks : '-*' files-changed-only : false ignore : 'dist/third-party-lib' is equivalent to - name : Install linter python package run : python3 -m pip install git+https://github.com/cpp-linter/cpp-linter-action@v1 - name : run linter as a python package run : | cpp-linter \\ --style=file \\ --tidy-checks='-*' \\ --files-changed-only=false \\ --ignore='dist/third-party-lib' Example \u00b6 Annotations \u00b6 Thread Comment \u00b6 Add C/C++ Lint Action badge in README \u00b6 You can show C/C++ Lint Action status with a badge in your repository README Example [ ![cpp-linter ]( https://github.com/cpp-linter/cpp-linter-action/actions/workflows/cpp-linter.yml/badge.svg )](https://github.com/cpp-linter/cpp-linter-action/actions/workflows/cpp-linter.yml) Have question or feedback? \u00b6 To provide feedback (requesting a feature or reporting a bug) please post to issues . License \u00b6 The scripts and documentation in this project are released under the MIT License","title":"Home"},{"location":"#cc-lint-action-clang-format-clang-tidy","text":"A Github Action for linting C/C++ code integrating clang-tidy and clang-format to collect feedback provided in the form of thread comments and/or annotations.","title":"C/C++ Lint Action | clang-format &amp; clang-tidy"},{"location":"#usage","text":"Create a new GitHub Actions workflow in your project, e.g. at .github/workflows/cpp-linter.yml The content of the file should be in the following format. # Workflow syntax: # https://help.github.com/en/articles/workflow-syntax-for-github-actions name : cpp-linter on : pull_request : types : [ opened , reopened ] # let PR-synchronize events be handled by push events push : jobs : cpp-linter : runs-on : ubuntu-latest steps : - uses : actions/checkout@v3 - uses : cpp-linter/cpp-linter-action@v1 id : linter env : GITHUB_TOKEN : ${{ secrets.GITHUB_TOKEN }} with : style : file - name : Fail fast?! if : steps.linter.outputs.checks-failed > 0 run : echo \"Some files failed the linting checks!\" # for actual deployment # run: exit 1","title":"Usage"},{"location":"#optional-inputs","text":"","title":"Optional Inputs"},{"location":"#style","text":"Description : The style rules to use. Set this to 'file' to have clang-format use the closest relative .clang-format file. Set this to a blank string ( '' ) to disable the use of clang-format entirely. Default: 'llvm'","title":"style"},{"location":"#extensions","text":"Description : The file extensions to run the action against. This is a comma-separated string. Default: 'c,h,C,H,cpp,hpp,cc,hh,c++,h++,cxx,hxx'","title":"extensions"},{"location":"#tidy-checks","text":"Description : Comma-separated list of globs with optional - prefix. Globs are processed in order of appearance in the list. Globs without - prefix add checks with matching names to the set, globs with the - prefix remove checks with matching names from the set of enabled checks. This option's value is appended to the value of the 'Checks' option in a .clang-tidy file (if any). It is possible to disable clang-tidy entirely by setting this option to '-*' . It is also possible to rely solely on a .clang-tidy config file by specifying this option as a blank string ( '' ). Default: 'boost-*,bugprone-*,performance-*,readability-*,portability-*,modernize-*,clang-analyzer-*,cppcoreguidelines-*'","title":"tidy-checks"},{"location":"#repo-root","text":"Description : The relative path to the repository root directory. This path is relative to the path designated as the runner's GITHUB_WORKSPACE environment variable. Default: '.'","title":"repo-root"},{"location":"#version","text":"Description : The desired version of the clang-tools to use. Accepted options are strings which can be 14, 13, 12, 11, 10, 9, or 8. Set this option to a blank string ( '' ) to use the platform's default installed version. This value can also be a path to where the clang tools are installed (if using a custom install location). Because all paths specified here are converted to absolute, using a relative path as a value may not be compatible when using the docker environment (see Running without the docker container ). Default: '12'","title":"version"},{"location":"#verbosity","text":"Description : This controls the action's verbosity in the workflow's logs. Supported options are defined by the python logging library's log levels . This option does not affect the verbosity of resulting thread comments or file annotations. Default: '10'","title":"verbosity"},{"location":"#lines-changed-only","text":"Description : This controls what part of the files are analyzed. The following values are accepted: false: All lines in a file are analyzed. true: Only lines in the diff that contain additions are analyzed. diff: All lines in the diff are analyzed (including unchanged lines but not subtractions). Default: false.","title":"lines-changed-only"},{"location":"#files-changed-only","text":"Description : Set this option to false to analyze any source files in the repo. This is automatically enabled if lines-changed-only is enabled. Default: true NOTE: The GITHUB_TOKEN should be supplied when running on a private repository with this option enabled, otherwise the runner does not not have the privilege to list changed files for an event. See Authenticating with the GITHUB_TOKEN","title":"files-changed-only"},{"location":"#ignore","text":"Description : Set this option with string of path(s) to ignore. In the case of multiple paths, you can use a pipe character ( | ) to separate the multiple paths. Multiple lines are forbidden as an input to this option; it must be a single string. This can also have files, but the file's relative path has to be specified as well. There is no need to use ./ for each entry; a blank string ( '' ) represents the repo-root path (specified by the repo-root input option). Submodules are automatically ignored. Hidden directories (beginning with a . ) are also ignored automatically. Prefix a path with a bang ( ! ) to make it explicitly not ignored. The order of multiple paths does not take precedence. The ! prefix can be applied to a submodule's path (if desired) but not hidden directories. Glob patterns are not supported here. All asterisk characters ( * ) are literal. Default: '.github'","title":"ignore"},{"location":"#thread-comments","text":"Description : Set this option to false to disable the use of thread comments as feedback. To use thread comments, the GITHUB_TOKEN (provided by Github to each repository) must be declared as an environment variable. See Authenticating with the GITHUB_TOKEN Default: false NOTE: If run on a private repository, then this feature is disabled because the GitHub REST API behaves differently for thread comments on a private repository.","title":"thread-comments"},{"location":"#file-annotations","text":"Description : Set this option to false to disable the use of file annotations as feedback. Default: true","title":"file-annotations"},{"location":"#database","text":"Description : The directory containing compilation database (like compile_commands.json) file. This option doesn't seems to work properly from the docker environment. Instead we recommend using this option when see running without the docker container . Default: ''","title":"database"},{"location":"#outputs","text":"This action creates 1 output variable named checks-failed . Even if the linting checks fail for source files this action will still pass, but users' CI workflows can use this action's output to exit the workflow early if that is desired.","title":"Outputs"},{"location":"#running-without-the-docker-container","text":"Some Continuous Integration environments require access to non-default compilers and/or non-standard libraries. To do this properly, the docker container should not be used due to it's isolated file system. Instead, you should use this action's python source code as an installed python package (see below).","title":"Running without the docker container"},{"location":"#using-the-python-source-code","text":"This action was originally designed to only be used on a runner with the Ubuntu Operating System. However, this action's source code (essentially a python package) can be used on any runner using the Windows, Ubuntu, or possibly even MacOS (untested) virtual environments. Note, some runners already ship with clang-format and/or clang-tidy. As of this writing, the following versions of clang-format and clang-tidy are already available: ubuntu-latest ships with v10, v11, and v12. More details . windows-latest ships with v13. More details . macos-latest ships with v13. More details . This example makes use of another action ( KyleMayes/install-llvm-action ) to install a certain version of clang-tidy and clang-format. on: pull_request: types: [opened, reopened] # let PR-synchronize events be handled by push events push: jobs: cpp-linter: runs-on: windows-latest steps: - uses: actions/checkout@v3 - uses: actions/setup-python@v4 # this step can be skipped if the desired # version already comes with the runner's OS - name: Install clang-tools uses: KyleMayes/install-llvm-action@v1 with: # v13 is the recommended minimum for the Visual Studio compiler (on Windows) version: 14 # specifying an install path is required (on Windows) because installing # multiple versions on Windows runners needs non-default install paths. directory: ${{ runner.temp }}/llvm - name: Install linter python package run: python3 -m pip install git+https://github.com/cpp-linter/cpp-linter-action@v1 - name: run linter as a python package id: linter # Pass the installed path to the '--version' argument. # Alternatively, pass the version number. # Example. run: cpp-linter --version=14 # Omit the version option if using the default version available in the OS. run: cpp-linter --version=${{ runner.temp }}/llvm - name: Fail fast?! if: steps.linter.outputs.checks-failed > 0 run: echo \"Some files failed the linting checks!\" # for actual deployment # run: exit 1 All input options listed above are specified by pre-pending a -- . You can also install this repo locally and run cpp-linter -h for more detail. For example: - uses : cpp-linter/cpp-linter-action@v1 with : style : file tidy-checks : '-*' files-changed-only : false ignore : 'dist/third-party-lib' is equivalent to - name : Install linter python package run : python3 -m pip install git+https://github.com/cpp-linter/cpp-linter-action@v1 - name : run linter as a python package run : | cpp-linter \\ --style=file \\ --tidy-checks='-*' \\ --files-changed-only=false \\ --ignore='dist/third-party-lib'","title":"Using the python source code"},{"location":"#example","text":"","title":"Example"},{"location":"#annotations","text":"","title":"Annotations"},{"location":"#thread-comment","text":"","title":"Thread Comment"},{"location":"#add-cc-lint-action-badge-in-readme","text":"You can show C/C++ Lint Action status with a badge in your repository README Example [ ![cpp-linter ]( https://github.com/cpp-linter/cpp-linter-action/actions/workflows/cpp-linter.yml/badge.svg )](https://github.com/cpp-linter/cpp-linter-action/actions/workflows/cpp-linter.yml)","title":"Add C/C++ Lint Action badge in README"},{"location":"#have-question-or-feedback","text":"To provide feedback (requesting a feature or reporting a bug) please post to issues .","title":"Have question or feedback?"},{"location":"#license","text":"The scripts and documentation in this project are released under the MIT License","title":"License"},{"location":"API%20Reference/cpp_linter.clang_format_xml/","text":"clang_format_xml module \u00b6 Info This API is experimental and not actually used in production. Parse output from clang-format's XML suggestions. FormatReplacement \u00b6 An object representing a single replacement. Attributes: Name Type Description cols int The columns number of where the suggestion starts on the line null_len int The number of bytes removed by suggestion text str The bytearray of the suggestion Source code in cpp_linter/clang_format_xml.py class FormatReplacement : \"\"\"An object representing a single replacement. Attributes: cols (int): The columns number of where the suggestion starts on the line null_len (int): The number of bytes removed by suggestion text (str): The `bytearray` of the suggestion \"\"\" def __init__ ( self , cols : int , null_len : int , text : str ) -> None : \"\"\" Args: cols: The columns number of where the suggestion starts on the line null_len: The number of bytes removed by suggestion text: The `bytearray` of the suggestion \"\"\" self . cols = cols self . null_len = null_len self . text = text def __repr__ ( self ) -> str : return ( f \"<FormatReplacement at cols { self . cols } removes { self . null_len } bytes\" f \" adds { len ( self . text ) } bytes>\" ) __init__ ( cols : int , null_len : int , text : str ) -> None \u00b6 Parameters: Name Type Description Default cols int The columns number of where the suggestion starts on the line required null_len int The number of bytes removed by suggestion required text str The bytearray of the suggestion required Source code in cpp_linter/clang_format_xml.py def __init__ ( self , cols : int , null_len : int , text : str ) -> None : \"\"\" Args: cols: The columns number of where the suggestion starts on the line null_len: The number of bytes removed by suggestion text: The `bytearray` of the suggestion \"\"\" self . cols = cols self . null_len = null_len self . text = text FormatReplacementLine \u00b6 An object that represents a replacement(s) for a single line. Attributes: Name Type Description line int The line number of where the suggestion starts replacements list A list of FormatReplacement object(s) representing suggestions. Source code in cpp_linter/clang_format_xml.py class FormatReplacementLine : \"\"\"An object that represents a replacement(s) for a single line. Attributes: line (int): The line number of where the suggestion starts replacements (list): A list of [`FormatReplacement`][cpp_linter.clang_format_xml.FormatReplacement] object(s) representing suggestions. \"\"\" def __init__ ( self , line_numb : int ): \"\"\" Args: line_numb: The line number of about the replacements \"\"\" self . line = line_numb self . replacements : List [ FormatReplacement ] = [] def __repr__ ( self ): return ( f \"<FormatReplacementLine @ line { self . line } \" f \"with { len ( self . replacements ) } replacements>\" ) __init__ ( line_numb : int ) \u00b6 Parameters: Name Type Description Default line_numb int The line number of about the replacements required Source code in cpp_linter/clang_format_xml.py def __init__ ( self , line_numb : int ): \"\"\" Args: line_numb: The line number of about the replacements \"\"\" self . line = line_numb self . replacements : List [ FormatReplacement ] = [] XMLFixit \u00b6 A single object to represent each suggestion. Attributes: Name Type Description filename str The source file that the suggestion concerns. replaced_lines list A list of [ FormatReplacementLine ][ cpp_linter.clang_format_xml.FormatReplacementLine] representing replacement(s) on a single line. Source code in cpp_linter/clang_format_xml.py class XMLFixit : \"\"\"A single object to represent each suggestion. Attributes: filename (str): The source file that the suggestion concerns. replaced_lines (list): A list of [`FormatReplacementLine`][ cpp_linter.clang_format_xml.FormatReplacementLine] representing replacement(s) on a single line. \"\"\" def __init__ ( self , filename : str ): \"\"\" Args: filename: The source file's name for which the contents of the xml file exported by clang-tidy. \"\"\" self . filename = PurePath ( filename ) . as_posix () self . replaced_lines : List [ FormatReplacementLine ] = [] def __repr__ ( self ) -> str : return ( f \"<XMLFixit with { len ( self . replaced_lines ) } lines of \" f \"replacements for { self . filename } >\" ) def log_command ( self , style : str , line_filter : List [ int ]) -> Optional [ str ]: \"\"\"Output a notification as a github log command. !!! info See Also - [An error message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-an-error-message) - [A warning message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-warning-message) - [A notice message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-notice-message) Args: style: The chosen code style guidelines. \"\"\" if style not in ( \"llvm\" , \"google\" , \"webkit\" , \"mozilla\" , \"gnu\" ): # potentially the style parameter could be a str of JSON/YML syntax style = \"Custom\" else : if style . startswith ( \"llvm\" ) or style . startswith ( \"gnu\" ): style = style . upper () else : style = style . title () line_list = [] for fix in self . replaced_lines : if not line_filter or ( line_filter and fix . line in line_filter ): line_list . append ( str ( fix . line )) if not line_list : return None return ( \"::notice file= {name} ,title=Run clang-format on {name} ::\" \"File {name} (lines {lines} ): Code does not conform to {style_guide} \" \"style guidelines.\" . format ( name = self . filename , lines = \", \" . join ( line_list ), style_guide = style , ) ) __init__ ( filename : str ) \u00b6 Parameters: Name Type Description Default filename str The source file's name for which the contents of the xml file exported by clang-tidy. required Source code in cpp_linter/clang_format_xml.py def __init__ ( self , filename : str ): \"\"\" Args: filename: The source file's name for which the contents of the xml file exported by clang-tidy. \"\"\" self . filename = PurePath ( filename ) . as_posix () self . replaced_lines : List [ FormatReplacementLine ] = [] log_command ( style : str , line_filter : List [ int ]) -> Optional [ str ] \u00b6 Output a notification as a github log command. Info An error message A warning message A notice message Parameters: Name Type Description Default style str The chosen code style guidelines. required Source code in cpp_linter/clang_format_xml.py def log_command ( self , style : str , line_filter : List [ int ]) -> Optional [ str ]: \"\"\"Output a notification as a github log command. !!! info See Also - [An error message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-an-error-message) - [A warning message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-warning-message) - [A notice message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-notice-message) Args: style: The chosen code style guidelines. \"\"\" if style not in ( \"llvm\" , \"google\" , \"webkit\" , \"mozilla\" , \"gnu\" ): # potentially the style parameter could be a str of JSON/YML syntax style = \"Custom\" else : if style . startswith ( \"llvm\" ) or style . startswith ( \"gnu\" ): style = style . upper () else : style = style . title () line_list = [] for fix in self . replaced_lines : if not line_filter or ( line_filter and fix . line in line_filter ): line_list . append ( str ( fix . line )) if not line_list : return None return ( \"::notice file= {name} ,title=Run clang-format on {name} ::\" \"File {name} (lines {lines} ): Code does not conform to {style_guide} \" \"style guidelines.\" . format ( name = self . filename , lines = \", \" . join ( line_list ), style_guide = style , ) ) parse_format_replacements_xml ( src_filename : str ) \u00b6 Parse XML output of replacements from clang-format. Output is saved to format_advice . Parameters: Name Type Description Default src_filename str The source file's name for which the contents of the xml file exported by clang-tidy. required Source code in cpp_linter/clang_format_xml.py def parse_format_replacements_xml ( src_filename : str ): \"\"\"Parse XML output of replacements from clang-format. Output is saved to [`format_advice`][cpp_linter.GlobalParser.format_advice]. Args: src_filename: The source file's name for which the contents of the xml file exported by clang-tidy. \"\"\" tree = ET . parse ( \"clang_format_output.xml\" ) fixit = XMLFixit ( src_filename ) for child in tree . getroot (): if child . tag == \"replacement\" : offset = int ( child . attrib [ \"offset\" ]) line , cols = get_line_cnt_from_cols ( src_filename , offset ) null_len = int ( child . attrib [ \"length\" ]) text = \"\" if child . text is None else child . text fix = FormatReplacement ( cols , null_len , text ) if not fixit . replaced_lines or ( fixit . replaced_lines and line != fixit . replaced_lines [ - 1 ] . line ): line_fix = FormatReplacementLine ( line ) line_fix . replacements . append ( fix ) fixit . replaced_lines . append ( line_fix ) elif fixit . replaced_lines and line == fixit . replaced_lines [ - 1 ] . line : fixit . replaced_lines [ - 1 ] . replacements . append ( fix ) GlobalParser . format_advice . append ( fixit )","title":"clang_format_xml module"},{"location":"API%20Reference/cpp_linter.clang_format_xml/#clang_format_xml-module","text":"Info This API is experimental and not actually used in production. Parse output from clang-format's XML suggestions.","title":"clang_format_xml module"},{"location":"API%20Reference/cpp_linter.clang_format_xml/#cpp_linter.clang_format_xml.FormatReplacement","text":"An object representing a single replacement. Attributes: Name Type Description cols int The columns number of where the suggestion starts on the line null_len int The number of bytes removed by suggestion text str The bytearray of the suggestion Source code in cpp_linter/clang_format_xml.py class FormatReplacement : \"\"\"An object representing a single replacement. Attributes: cols (int): The columns number of where the suggestion starts on the line null_len (int): The number of bytes removed by suggestion text (str): The `bytearray` of the suggestion \"\"\" def __init__ ( self , cols : int , null_len : int , text : str ) -> None : \"\"\" Args: cols: The columns number of where the suggestion starts on the line null_len: The number of bytes removed by suggestion text: The `bytearray` of the suggestion \"\"\" self . cols = cols self . null_len = null_len self . text = text def __repr__ ( self ) -> str : return ( f \"<FormatReplacement at cols { self . cols } removes { self . null_len } bytes\" f \" adds { len ( self . text ) } bytes>\" )","title":"FormatReplacement"},{"location":"API%20Reference/cpp_linter.clang_format_xml/#cpp_linter.clang_format_xml.FormatReplacement.__init__","text":"Parameters: Name Type Description Default cols int The columns number of where the suggestion starts on the line required null_len int The number of bytes removed by suggestion required text str The bytearray of the suggestion required Source code in cpp_linter/clang_format_xml.py def __init__ ( self , cols : int , null_len : int , text : str ) -> None : \"\"\" Args: cols: The columns number of where the suggestion starts on the line null_len: The number of bytes removed by suggestion text: The `bytearray` of the suggestion \"\"\" self . cols = cols self . null_len = null_len self . text = text","title":"__init__()"},{"location":"API%20Reference/cpp_linter.clang_format_xml/#cpp_linter.clang_format_xml.FormatReplacementLine","text":"An object that represents a replacement(s) for a single line. Attributes: Name Type Description line int The line number of where the suggestion starts replacements list A list of FormatReplacement object(s) representing suggestions. Source code in cpp_linter/clang_format_xml.py class FormatReplacementLine : \"\"\"An object that represents a replacement(s) for a single line. Attributes: line (int): The line number of where the suggestion starts replacements (list): A list of [`FormatReplacement`][cpp_linter.clang_format_xml.FormatReplacement] object(s) representing suggestions. \"\"\" def __init__ ( self , line_numb : int ): \"\"\" Args: line_numb: The line number of about the replacements \"\"\" self . line = line_numb self . replacements : List [ FormatReplacement ] = [] def __repr__ ( self ): return ( f \"<FormatReplacementLine @ line { self . line } \" f \"with { len ( self . replacements ) } replacements>\" )","title":"FormatReplacementLine"},{"location":"API%20Reference/cpp_linter.clang_format_xml/#cpp_linter.clang_format_xml.FormatReplacementLine.__init__","text":"Parameters: Name Type Description Default line_numb int The line number of about the replacements required Source code in cpp_linter/clang_format_xml.py def __init__ ( self , line_numb : int ): \"\"\" Args: line_numb: The line number of about the replacements \"\"\" self . line = line_numb self . replacements : List [ FormatReplacement ] = []","title":"__init__()"},{"location":"API%20Reference/cpp_linter.clang_format_xml/#cpp_linter.clang_format_xml.XMLFixit","text":"A single object to represent each suggestion. Attributes: Name Type Description filename str The source file that the suggestion concerns. replaced_lines list A list of [ FormatReplacementLine ][ cpp_linter.clang_format_xml.FormatReplacementLine] representing replacement(s) on a single line. Source code in cpp_linter/clang_format_xml.py class XMLFixit : \"\"\"A single object to represent each suggestion. Attributes: filename (str): The source file that the suggestion concerns. replaced_lines (list): A list of [`FormatReplacementLine`][ cpp_linter.clang_format_xml.FormatReplacementLine] representing replacement(s) on a single line. \"\"\" def __init__ ( self , filename : str ): \"\"\" Args: filename: The source file's name for which the contents of the xml file exported by clang-tidy. \"\"\" self . filename = PurePath ( filename ) . as_posix () self . replaced_lines : List [ FormatReplacementLine ] = [] def __repr__ ( self ) -> str : return ( f \"<XMLFixit with { len ( self . replaced_lines ) } lines of \" f \"replacements for { self . filename } >\" ) def log_command ( self , style : str , line_filter : List [ int ]) -> Optional [ str ]: \"\"\"Output a notification as a github log command. !!! info See Also - [An error message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-an-error-message) - [A warning message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-warning-message) - [A notice message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-notice-message) Args: style: The chosen code style guidelines. \"\"\" if style not in ( \"llvm\" , \"google\" , \"webkit\" , \"mozilla\" , \"gnu\" ): # potentially the style parameter could be a str of JSON/YML syntax style = \"Custom\" else : if style . startswith ( \"llvm\" ) or style . startswith ( \"gnu\" ): style = style . upper () else : style = style . title () line_list = [] for fix in self . replaced_lines : if not line_filter or ( line_filter and fix . line in line_filter ): line_list . append ( str ( fix . line )) if not line_list : return None return ( \"::notice file= {name} ,title=Run clang-format on {name} ::\" \"File {name} (lines {lines} ): Code does not conform to {style_guide} \" \"style guidelines.\" . format ( name = self . filename , lines = \", \" . join ( line_list ), style_guide = style , ) )","title":"XMLFixit"},{"location":"API%20Reference/cpp_linter.clang_format_xml/#cpp_linter.clang_format_xml.XMLFixit.__init__","text":"Parameters: Name Type Description Default filename str The source file's name for which the contents of the xml file exported by clang-tidy. required Source code in cpp_linter/clang_format_xml.py def __init__ ( self , filename : str ): \"\"\" Args: filename: The source file's name for which the contents of the xml file exported by clang-tidy. \"\"\" self . filename = PurePath ( filename ) . as_posix () self . replaced_lines : List [ FormatReplacementLine ] = []","title":"__init__()"},{"location":"API%20Reference/cpp_linter.clang_format_xml/#cpp_linter.clang_format_xml.XMLFixit.log_command","text":"Output a notification as a github log command. Info An error message A warning message A notice message Parameters: Name Type Description Default style str The chosen code style guidelines. required Source code in cpp_linter/clang_format_xml.py def log_command ( self , style : str , line_filter : List [ int ]) -> Optional [ str ]: \"\"\"Output a notification as a github log command. !!! info See Also - [An error message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-an-error-message) - [A warning message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-warning-message) - [A notice message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-notice-message) Args: style: The chosen code style guidelines. \"\"\" if style not in ( \"llvm\" , \"google\" , \"webkit\" , \"mozilla\" , \"gnu\" ): # potentially the style parameter could be a str of JSON/YML syntax style = \"Custom\" else : if style . startswith ( \"llvm\" ) or style . startswith ( \"gnu\" ): style = style . upper () else : style = style . title () line_list = [] for fix in self . replaced_lines : if not line_filter or ( line_filter and fix . line in line_filter ): line_list . append ( str ( fix . line )) if not line_list : return None return ( \"::notice file= {name} ,title=Run clang-format on {name} ::\" \"File {name} (lines {lines} ): Code does not conform to {style_guide} \" \"style guidelines.\" . format ( name = self . filename , lines = \", \" . join ( line_list ), style_guide = style , ) )","title":"log_command()"},{"location":"API%20Reference/cpp_linter.clang_format_xml/#cpp_linter.clang_format_xml.parse_format_replacements_xml","text":"Parse XML output of replacements from clang-format. Output is saved to format_advice . Parameters: Name Type Description Default src_filename str The source file's name for which the contents of the xml file exported by clang-tidy. required Source code in cpp_linter/clang_format_xml.py def parse_format_replacements_xml ( src_filename : str ): \"\"\"Parse XML output of replacements from clang-format. Output is saved to [`format_advice`][cpp_linter.GlobalParser.format_advice]. Args: src_filename: The source file's name for which the contents of the xml file exported by clang-tidy. \"\"\" tree = ET . parse ( \"clang_format_output.xml\" ) fixit = XMLFixit ( src_filename ) for child in tree . getroot (): if child . tag == \"replacement\" : offset = int ( child . attrib [ \"offset\" ]) line , cols = get_line_cnt_from_cols ( src_filename , offset ) null_len = int ( child . attrib [ \"length\" ]) text = \"\" if child . text is None else child . text fix = FormatReplacement ( cols , null_len , text ) if not fixit . replaced_lines or ( fixit . replaced_lines and line != fixit . replaced_lines [ - 1 ] . line ): line_fix = FormatReplacementLine ( line ) line_fix . replacements . append ( fix ) fixit . replaced_lines . append ( line_fix ) elif fixit . replaced_lines and line == fixit . replaced_lines [ - 1 ] . line : fixit . replaced_lines [ - 1 ] . replacements . append ( fix ) GlobalParser . format_advice . append ( fixit )","title":"parse_format_replacements_xml()"},{"location":"API%20Reference/cpp_linter.clang_tidy/","text":"clang_tidy module \u00b6 Parse output from clang-tidy's stdout TidyNotification \u00b6 Create a object that decodes info from the clang-tidy output's initial line that details a specific notification. Attributes: Name Type Description diagnostic str The clang-tidy check that enabled the notification. filename str The source filename concerning the notification. line int The line number of the source file. cols int The columns of the line that triggered the notification. note_type str The priority level of notification (warning/error). note_info str The rationale of the notification. fixit_lines list A list of lines ( str ) for the code-block in the notification. Source code in cpp_linter/clang_tidy.py class TidyNotification : \"\"\"Create a object that decodes info from the clang-tidy output's initial line that details a specific notification. Attributes: diagnostic (str): The clang-tidy check that enabled the notification. filename (str): The source filename concerning the notification. line (int): The line number of the source file. cols (int): The columns of the line that triggered the notification. note_type (str): The priority level of notification (warning/error). note_info (str): The rationale of the notification. fixit_lines (list): A `list` of lines (`str`) for the code-block in the notification. \"\"\" def __init__ ( self , notification_line : Tuple [ str , Union [ int , str ], Union [ int , str ], str , str , str ], ): \"\"\" Args: notification_line: The first line in the notification parsed into a tuple of string that represent the different components of the notification's details. \"\"\" # logger.debug(\"Creating tidy note from line %s\", notification_line) ( self . filename , self . line , self . cols , self . note_type , self . note_info , self . diagnostic , ) = notification_line self . note_info = self . note_info . strip () self . note_type = self . note_type . strip () self . line = int ( self . line ) self . cols = int ( self . cols ) self . filename = ( PurePath ( self . filename ) . as_posix () . replace ( Path . cwd () . as_posix (), \"\" ) ) self . fixit_lines : List [ str ] = [] def __repr__ ( self ) -> str : concerned_code = \"\" if self . fixit_lines : if not self . fixit_lines [ - 1 ] . endswith ( \" \\n \" ): # some notifications' code-blocks don't end in a LF self . fixit_lines [ - 1 ] += \" \\n \" # and they should for us concerned_code = \"``` {} \\n {} ``` \\n \" . format ( PurePath ( self . filename ) . suffix . lstrip ( \".\" ), \" \\n \" . join ( self . fixit_lines ), ) return ( \"<details open> \\n <summary><strong> {} : {} : {} :</strong> {} : [ {} ]\" \" \\n\\n > {} \\n </summary><p> \\n\\n {} </p> \\n </details> \\n\\n \" . format ( self . filename , self . line , self . cols , self . note_type , self . diagnostic , self . note_info , concerned_code , ) ) def log_command ( self ) -> str : \"\"\"Output the notification as a github log command. !!! info See Also - [An error message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-an-error-message) - [A warning message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-warning-message) - [A notice message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-notice-message) \"\"\" filename = self . filename . replace ( \" \\\\ \" , \"/\" ) return ( \":: {} file= {file} ,line= {line} ,title= {file} : {line} : {cols} [ {diag} ]::\" \" {info} \" . format ( \"notice\" if self . note_type . startswith ( \"note\" ) else self . note_type , file = filename , line = self . line , cols = self . cols , diag = self . diagnostic , info = self . note_info , ) ) __init__ ( notification_line : Tuple [ str , Union [ int , str ], Union [ int , str ], str , str , str ]) \u00b6 Parameters: Name Type Description Default notification_line Tuple [ str , Union [ int , str ], Union [ int , str ], str , str , str ] The first line in the notification parsed into a tuple of string that represent the different components of the notification's details. required Source code in cpp_linter/clang_tidy.py def __init__ ( self , notification_line : Tuple [ str , Union [ int , str ], Union [ int , str ], str , str , str ], ): \"\"\" Args: notification_line: The first line in the notification parsed into a tuple of string that represent the different components of the notification's details. \"\"\" # logger.debug(\"Creating tidy note from line %s\", notification_line) ( self . filename , self . line , self . cols , self . note_type , self . note_info , self . diagnostic , ) = notification_line self . note_info = self . note_info . strip () self . note_type = self . note_type . strip () self . line = int ( self . line ) self . cols = int ( self . cols ) self . filename = ( PurePath ( self . filename ) . as_posix () . replace ( Path . cwd () . as_posix (), \"\" ) ) self . fixit_lines : List [ str ] = [] log_command () -> str \u00b6 Output the notification as a github log command. Info An error message A warning message A notice message Source code in cpp_linter/clang_tidy.py def log_command ( self ) -> str : \"\"\"Output the notification as a github log command. !!! info See Also - [An error message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-an-error-message) - [A warning message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-warning-message) - [A notice message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-notice-message) \"\"\" filename = self . filename . replace ( \" \\\\ \" , \"/\" ) return ( \":: {} file= {file} ,line= {line} ,title= {file} : {line} : {cols} [ {diag} ]::\" \" {info} \" . format ( \"notice\" if self . note_type . startswith ( \"note\" ) else self . note_type , file = filename , line = self . line , cols = self . cols , diag = self . diagnostic , info = self . note_info , ) ) parse_tidy_output () -> None \u00b6 Parse clang-tidy output in a file created from stdout. Source code in cpp_linter/clang_tidy.py def parse_tidy_output () -> None : \"\"\"Parse clang-tidy output in a file created from stdout.\"\"\" notification = None tidy_out = Path ( \"clang_tidy_report.txt\" ) . read_text ( encoding = \"utf-8\" ) for line in tidy_out . splitlines (): match = re . match ( NOTE_HEADER , line ) if match is not None : notification = TidyNotification ( cast ( Tuple [ str , Union [ int , str ], Union [ int , str ], str , str , str ], match . groups (), ) ) GlobalParser . tidy_notes . append ( notification ) elif notification is not None : # append lines of code that are part of # the previous line's notification notification . fixit_lines . append ( line )","title":"clang_tidy module"},{"location":"API%20Reference/cpp_linter.clang_tidy/#clang_tidy-module","text":"Parse output from clang-tidy's stdout","title":"clang_tidy module"},{"location":"API%20Reference/cpp_linter.clang_tidy/#cpp_linter.clang_tidy.TidyNotification","text":"Create a object that decodes info from the clang-tidy output's initial line that details a specific notification. Attributes: Name Type Description diagnostic str The clang-tidy check that enabled the notification. filename str The source filename concerning the notification. line int The line number of the source file. cols int The columns of the line that triggered the notification. note_type str The priority level of notification (warning/error). note_info str The rationale of the notification. fixit_lines list A list of lines ( str ) for the code-block in the notification. Source code in cpp_linter/clang_tidy.py class TidyNotification : \"\"\"Create a object that decodes info from the clang-tidy output's initial line that details a specific notification. Attributes: diagnostic (str): The clang-tidy check that enabled the notification. filename (str): The source filename concerning the notification. line (int): The line number of the source file. cols (int): The columns of the line that triggered the notification. note_type (str): The priority level of notification (warning/error). note_info (str): The rationale of the notification. fixit_lines (list): A `list` of lines (`str`) for the code-block in the notification. \"\"\" def __init__ ( self , notification_line : Tuple [ str , Union [ int , str ], Union [ int , str ], str , str , str ], ): \"\"\" Args: notification_line: The first line in the notification parsed into a tuple of string that represent the different components of the notification's details. \"\"\" # logger.debug(\"Creating tidy note from line %s\", notification_line) ( self . filename , self . line , self . cols , self . note_type , self . note_info , self . diagnostic , ) = notification_line self . note_info = self . note_info . strip () self . note_type = self . note_type . strip () self . line = int ( self . line ) self . cols = int ( self . cols ) self . filename = ( PurePath ( self . filename ) . as_posix () . replace ( Path . cwd () . as_posix (), \"\" ) ) self . fixit_lines : List [ str ] = [] def __repr__ ( self ) -> str : concerned_code = \"\" if self . fixit_lines : if not self . fixit_lines [ - 1 ] . endswith ( \" \\n \" ): # some notifications' code-blocks don't end in a LF self . fixit_lines [ - 1 ] += \" \\n \" # and they should for us concerned_code = \"``` {} \\n {} ``` \\n \" . format ( PurePath ( self . filename ) . suffix . lstrip ( \".\" ), \" \\n \" . join ( self . fixit_lines ), ) return ( \"<details open> \\n <summary><strong> {} : {} : {} :</strong> {} : [ {} ]\" \" \\n\\n > {} \\n </summary><p> \\n\\n {} </p> \\n </details> \\n\\n \" . format ( self . filename , self . line , self . cols , self . note_type , self . diagnostic , self . note_info , concerned_code , ) ) def log_command ( self ) -> str : \"\"\"Output the notification as a github log command. !!! info See Also - [An error message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-an-error-message) - [A warning message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-warning-message) - [A notice message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-notice-message) \"\"\" filename = self . filename . replace ( \" \\\\ \" , \"/\" ) return ( \":: {} file= {file} ,line= {line} ,title= {file} : {line} : {cols} [ {diag} ]::\" \" {info} \" . format ( \"notice\" if self . note_type . startswith ( \"note\" ) else self . note_type , file = filename , line = self . line , cols = self . cols , diag = self . diagnostic , info = self . note_info , ) )","title":"TidyNotification"},{"location":"API%20Reference/cpp_linter.clang_tidy/#cpp_linter.clang_tidy.TidyNotification.__init__","text":"Parameters: Name Type Description Default notification_line Tuple [ str , Union [ int , str ], Union [ int , str ], str , str , str ] The first line in the notification parsed into a tuple of string that represent the different components of the notification's details. required Source code in cpp_linter/clang_tidy.py def __init__ ( self , notification_line : Tuple [ str , Union [ int , str ], Union [ int , str ], str , str , str ], ): \"\"\" Args: notification_line: The first line in the notification parsed into a tuple of string that represent the different components of the notification's details. \"\"\" # logger.debug(\"Creating tidy note from line %s\", notification_line) ( self . filename , self . line , self . cols , self . note_type , self . note_info , self . diagnostic , ) = notification_line self . note_info = self . note_info . strip () self . note_type = self . note_type . strip () self . line = int ( self . line ) self . cols = int ( self . cols ) self . filename = ( PurePath ( self . filename ) . as_posix () . replace ( Path . cwd () . as_posix (), \"\" ) ) self . fixit_lines : List [ str ] = []","title":"__init__()"},{"location":"API%20Reference/cpp_linter.clang_tidy/#cpp_linter.clang_tidy.TidyNotification.log_command","text":"Output the notification as a github log command. Info An error message A warning message A notice message Source code in cpp_linter/clang_tidy.py def log_command ( self ) -> str : \"\"\"Output the notification as a github log command. !!! info See Also - [An error message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-an-error-message) - [A warning message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-warning-message) - [A notice message](https://docs.github.com/en/actions/learn-github- actions/workflow-commands-for-github-actions#setting-a-notice-message) \"\"\" filename = self . filename . replace ( \" \\\\ \" , \"/\" ) return ( \":: {} file= {file} ,line= {line} ,title= {file} : {line} : {cols} [ {diag} ]::\" \" {info} \" . format ( \"notice\" if self . note_type . startswith ( \"note\" ) else self . note_type , file = filename , line = self . line , cols = self . cols , diag = self . diagnostic , info = self . note_info , ) )","title":"log_command()"},{"location":"API%20Reference/cpp_linter.clang_tidy/#cpp_linter.clang_tidy.parse_tidy_output","text":"Parse clang-tidy output in a file created from stdout. Source code in cpp_linter/clang_tidy.py def parse_tidy_output () -> None : \"\"\"Parse clang-tidy output in a file created from stdout.\"\"\" notification = None tidy_out = Path ( \"clang_tidy_report.txt\" ) . read_text ( encoding = \"utf-8\" ) for line in tidy_out . splitlines (): match = re . match ( NOTE_HEADER , line ) if match is not None : notification = TidyNotification ( cast ( Tuple [ str , Union [ int , str ], Union [ int , str ], str , str , str ], match . groups (), ) ) GlobalParser . tidy_notes . append ( notification ) elif notification is not None : # append lines of code that are part of # the previous line's notification notification . fixit_lines . append ( line )","title":"parse_tidy_output()"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/","text":"clang_tidy_yml module \u00b6 Info This API is experimental and not actually used in production. Parse output from clang-tidy's YML format TidyDiagnostic \u00b6 Create an object that represents a diagnostic output found in the YAML exported from clang-tidy. Attributes: Name Type Description name str The diagnostic name message str The diagnostic message line int The line number that triggered the diagnostic cols int The columns of the line that triggered the diagnostic null_len int The number of bytes replaced by suggestions replacements list The list of TidyReplacement objects. Source code in cpp_linter/clang_tidy_yml.py class TidyDiagnostic : \"\"\"Create an object that represents a diagnostic output found in the YAML exported from clang-tidy. Attributes: name (str): The diagnostic name message (str): The diagnostic message line (int): The line number that triggered the diagnostic cols (int): The columns of the `line` that triggered the diagnostic null_len (int): The number of bytes replaced by suggestions replacements (list): The `list` of [`TidyReplacement`][cpp_linter.clang_tidy_yml.TidyReplacement] objects. \"\"\" def __init__ ( self , diagnostic_name : str ): \"\"\" Args: diagnostic_name: The name of the check that got triggered. \"\"\" self . name = diagnostic_name self . message = \"\" self . line = 0 self . cols = 0 self . null_len = 0 self . replacements : List [ \"TidyReplacement\" ] = [] def __repr__ ( self ): \"\"\"a str representation of all attributes.\"\"\" return ( f \"<TidyDiagnostic { self . name } @ line { self . line } cols { self . cols } : \" f \" { len ( self . replacements ) } replacements>\" ) __init__ ( diagnostic_name : str ) \u00b6 Parameters: Name Type Description Default diagnostic_name str The name of the check that got triggered. required Source code in cpp_linter/clang_tidy_yml.py def __init__ ( self , diagnostic_name : str ): \"\"\" Args: diagnostic_name: The name of the check that got triggered. \"\"\" self . name = diagnostic_name self . message = \"\" self . line = 0 self . cols = 0 self . null_len = 0 self . replacements : List [ \"TidyReplacement\" ] = [] __repr__ () \u00b6 a str representation of all attributes. Source code in cpp_linter/clang_tidy_yml.py def __repr__ ( self ): \"\"\"a str representation of all attributes.\"\"\" return ( f \"<TidyDiagnostic { self . name } @ line { self . line } cols { self . cols } : \" f \" { len ( self . replacements ) } replacements>\" ) TidyReplacement \u00b6 Create an object representing a clang-tidy suggested replacement. Attributes: Name Type Description line int The replacement content's starting line cols int The replacement content's starting columns null_len int The number of bytes discarded from cols text bytes The replacement content's text. Source code in cpp_linter/clang_tidy_yml.py class TidyReplacement : \"\"\"Create an object representing a clang-tidy suggested replacement. Attributes: line (int): The replacement content's starting line cols (int): The replacement content's starting columns null_len (int): The number of bytes discarded from `cols` text (bytes): The replacement content's text. \"\"\" def __init__ ( self , line_cnt : int , cols : int , length : int ): \"\"\" Args: line_cnt: The replacement content's starting line cols: The replacement content's starting columns length: The number of bytes discarded from `cols` \"\"\" self . line = line_cnt self . cols = cols self . null_len = length self . text : bytes = b \"\" def __repr__ ( self ) -> str : return ( f \"<TidyReplacement @ line { self . line } cols { self . cols } : \" f \"added lines { len ( self . text ) } discarded bytes { self . null_len } >\" ) __init__ ( line_cnt : int , cols : int , length : int ) \u00b6 Parameters: Name Type Description Default line_cnt int The replacement content's starting line required cols int The replacement content's starting columns required length int The number of bytes discarded from cols required Source code in cpp_linter/clang_tidy_yml.py def __init__ ( self , line_cnt : int , cols : int , length : int ): \"\"\" Args: line_cnt: The replacement content's starting line cols: The replacement content's starting columns length: The number of bytes discarded from `cols` \"\"\" self . line = line_cnt self . cols = cols self . null_len = length self . text : bytes = b \"\" YMLFixit \u00b6 A single object to represent each suggestion. Attributes: Name Type Description filename str The source file's name concerning the suggestion. diagnostics list The list of TidyDiagnostic objects. Source code in cpp_linter/clang_tidy_yml.py class YMLFixit : \"\"\"A single object to represent each suggestion. Attributes: filename (str): The source file's name concerning the suggestion. diagnostics (list): The `list` of [`TidyDiagnostic`][cpp_linter.clang_tidy_yml.TidyDiagnostic] objects. \"\"\" def __init__ ( self , filename : str ) -> None : \"\"\" Args: filename: The source file's name (with path) concerning the suggestion. \"\"\" self . filename = PurePath ( filename ) . relative_to ( Path . cwd ()) . as_posix () self . diagnostics : List [ TidyDiagnostic ] = [] def __repr__ ( self ) -> str : return ( f \"<YMLFixit ( { len ( self . diagnostics ) } diagnostics) for file \" f \" { self . filename } >\" ) __init__ ( filename : str ) -> None \u00b6 Parameters: Name Type Description Default filename str The source file's name (with path) concerning the suggestion. required Source code in cpp_linter/clang_tidy_yml.py def __init__ ( self , filename : str ) -> None : \"\"\" Args: filename: The source file's name (with path) concerning the suggestion. \"\"\" self . filename = PurePath ( filename ) . relative_to ( Path . cwd ()) . as_posix () self . diagnostics : List [ TidyDiagnostic ] = [] parse_tidy_suggestions_yml () \u00b6 Read a YAML file from clang-tidy and create a list of suggestions from it. Output is saved to tidy_advice . Source code in cpp_linter/clang_tidy_yml.py def parse_tidy_suggestions_yml (): \"\"\"Read a YAML file from clang-tidy and create a list of suggestions from it. Output is saved to [`tidy_advice`][cpp_linter.GlobalParser.tidy_advice]. \"\"\" yml_file = Path ( \"clang_tidy_output.yml\" ) . read_text ( encoding = \"utf-8\" ) yml = yaml . safe_load ( yml_file ) fixit = YMLFixit ( yml [ \"MainSourceFile\" ]) for diag_results in yml [ \"Diagnostics\" ]: diag = TidyDiagnostic ( diag_results [ \"DiagnosticName\" ]) if \"DiagnosticMessage\" in cast ( Dict [ str , Any ], diag_results ) . keys (): msg = diag_results [ \"DiagnosticMessage\" ][ \"Message\" ] offset = diag_results [ \"DiagnosticMessage\" ][ \"FileOffset\" ] replacements = diag_results [ \"DiagnosticMessage\" ][ \"Replacements\" ] else : # prior to clang-tidy v9, the YML output was structured differently msg = diag_results [ \"Message\" ] offset = diag_results [ \"FileOffset\" ] replacements = diag_results [ \"Replacements\" ] diag . message = msg diag . line , diag . cols = get_line_cnt_from_cols ( yml [ \"MainSourceFile\" ], offset ) for replacement in [] if replacements is None else replacements : line_cnt , cols = get_line_cnt_from_cols ( yml [ \"MainSourceFile\" ], replacement [ \"Offset\" ] ) fix = TidyReplacement ( line_cnt , cols , replacement [ \"Length\" ]) fix . text = bytes ( replacement [ \"ReplacementText\" ], encoding = \"utf-8\" ) if fix . text . startswith ( b \"header is missing header guard\" ): logger . debug ( \"filtering header guard suggestion (making relative to repo root)\" ) fix . text = fix . text . replace ( CWD_HEADER_GUARD , b \"\" ) diag . replacements . append ( fix ) fixit . diagnostics . append ( diag ) # filter out absolute header guards GlobalParser . tidy_advice . append ( fixit )","title":"clang_tidy_yml module"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/#clang_tidy_yml-module","text":"Info This API is experimental and not actually used in production. Parse output from clang-tidy's YML format","title":"clang_tidy_yml module"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/#cpp_linter.clang_tidy_yml.TidyDiagnostic","text":"Create an object that represents a diagnostic output found in the YAML exported from clang-tidy. Attributes: Name Type Description name str The diagnostic name message str The diagnostic message line int The line number that triggered the diagnostic cols int The columns of the line that triggered the diagnostic null_len int The number of bytes replaced by suggestions replacements list The list of TidyReplacement objects. Source code in cpp_linter/clang_tidy_yml.py class TidyDiagnostic : \"\"\"Create an object that represents a diagnostic output found in the YAML exported from clang-tidy. Attributes: name (str): The diagnostic name message (str): The diagnostic message line (int): The line number that triggered the diagnostic cols (int): The columns of the `line` that triggered the diagnostic null_len (int): The number of bytes replaced by suggestions replacements (list): The `list` of [`TidyReplacement`][cpp_linter.clang_tidy_yml.TidyReplacement] objects. \"\"\" def __init__ ( self , diagnostic_name : str ): \"\"\" Args: diagnostic_name: The name of the check that got triggered. \"\"\" self . name = diagnostic_name self . message = \"\" self . line = 0 self . cols = 0 self . null_len = 0 self . replacements : List [ \"TidyReplacement\" ] = [] def __repr__ ( self ): \"\"\"a str representation of all attributes.\"\"\" return ( f \"<TidyDiagnostic { self . name } @ line { self . line } cols { self . cols } : \" f \" { len ( self . replacements ) } replacements>\" )","title":"TidyDiagnostic"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/#cpp_linter.clang_tidy_yml.TidyDiagnostic.__init__","text":"Parameters: Name Type Description Default diagnostic_name str The name of the check that got triggered. required Source code in cpp_linter/clang_tidy_yml.py def __init__ ( self , diagnostic_name : str ): \"\"\" Args: diagnostic_name: The name of the check that got triggered. \"\"\" self . name = diagnostic_name self . message = \"\" self . line = 0 self . cols = 0 self . null_len = 0 self . replacements : List [ \"TidyReplacement\" ] = []","title":"__init__()"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/#cpp_linter.clang_tidy_yml.TidyDiagnostic.__repr__","text":"a str representation of all attributes. Source code in cpp_linter/clang_tidy_yml.py def __repr__ ( self ): \"\"\"a str representation of all attributes.\"\"\" return ( f \"<TidyDiagnostic { self . name } @ line { self . line } cols { self . cols } : \" f \" { len ( self . replacements ) } replacements>\" )","title":"__repr__()"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/#cpp_linter.clang_tidy_yml.TidyReplacement","text":"Create an object representing a clang-tidy suggested replacement. Attributes: Name Type Description line int The replacement content's starting line cols int The replacement content's starting columns null_len int The number of bytes discarded from cols text bytes The replacement content's text. Source code in cpp_linter/clang_tidy_yml.py class TidyReplacement : \"\"\"Create an object representing a clang-tidy suggested replacement. Attributes: line (int): The replacement content's starting line cols (int): The replacement content's starting columns null_len (int): The number of bytes discarded from `cols` text (bytes): The replacement content's text. \"\"\" def __init__ ( self , line_cnt : int , cols : int , length : int ): \"\"\" Args: line_cnt: The replacement content's starting line cols: The replacement content's starting columns length: The number of bytes discarded from `cols` \"\"\" self . line = line_cnt self . cols = cols self . null_len = length self . text : bytes = b \"\" def __repr__ ( self ) -> str : return ( f \"<TidyReplacement @ line { self . line } cols { self . cols } : \" f \"added lines { len ( self . text ) } discarded bytes { self . null_len } >\" )","title":"TidyReplacement"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/#cpp_linter.clang_tidy_yml.TidyReplacement.__init__","text":"Parameters: Name Type Description Default line_cnt int The replacement content's starting line required cols int The replacement content's starting columns required length int The number of bytes discarded from cols required Source code in cpp_linter/clang_tidy_yml.py def __init__ ( self , line_cnt : int , cols : int , length : int ): \"\"\" Args: line_cnt: The replacement content's starting line cols: The replacement content's starting columns length: The number of bytes discarded from `cols` \"\"\" self . line = line_cnt self . cols = cols self . null_len = length self . text : bytes = b \"\"","title":"__init__()"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/#cpp_linter.clang_tidy_yml.YMLFixit","text":"A single object to represent each suggestion. Attributes: Name Type Description filename str The source file's name concerning the suggestion. diagnostics list The list of TidyDiagnostic objects. Source code in cpp_linter/clang_tidy_yml.py class YMLFixit : \"\"\"A single object to represent each suggestion. Attributes: filename (str): The source file's name concerning the suggestion. diagnostics (list): The `list` of [`TidyDiagnostic`][cpp_linter.clang_tidy_yml.TidyDiagnostic] objects. \"\"\" def __init__ ( self , filename : str ) -> None : \"\"\" Args: filename: The source file's name (with path) concerning the suggestion. \"\"\" self . filename = PurePath ( filename ) . relative_to ( Path . cwd ()) . as_posix () self . diagnostics : List [ TidyDiagnostic ] = [] def __repr__ ( self ) -> str : return ( f \"<YMLFixit ( { len ( self . diagnostics ) } diagnostics) for file \" f \" { self . filename } >\" )","title":"YMLFixit"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/#cpp_linter.clang_tidy_yml.YMLFixit.__init__","text":"Parameters: Name Type Description Default filename str The source file's name (with path) concerning the suggestion. required Source code in cpp_linter/clang_tidy_yml.py def __init__ ( self , filename : str ) -> None : \"\"\" Args: filename: The source file's name (with path) concerning the suggestion. \"\"\" self . filename = PurePath ( filename ) . relative_to ( Path . cwd ()) . as_posix () self . diagnostics : List [ TidyDiagnostic ] = []","title":"__init__()"},{"location":"API%20Reference/cpp_linter.clang_tidy_yml/#cpp_linter.clang_tidy_yml.parse_tidy_suggestions_yml","text":"Read a YAML file from clang-tidy and create a list of suggestions from it. Output is saved to tidy_advice . Source code in cpp_linter/clang_tidy_yml.py def parse_tidy_suggestions_yml (): \"\"\"Read a YAML file from clang-tidy and create a list of suggestions from it. Output is saved to [`tidy_advice`][cpp_linter.GlobalParser.tidy_advice]. \"\"\" yml_file = Path ( \"clang_tidy_output.yml\" ) . read_text ( encoding = \"utf-8\" ) yml = yaml . safe_load ( yml_file ) fixit = YMLFixit ( yml [ \"MainSourceFile\" ]) for diag_results in yml [ \"Diagnostics\" ]: diag = TidyDiagnostic ( diag_results [ \"DiagnosticName\" ]) if \"DiagnosticMessage\" in cast ( Dict [ str , Any ], diag_results ) . keys (): msg = diag_results [ \"DiagnosticMessage\" ][ \"Message\" ] offset = diag_results [ \"DiagnosticMessage\" ][ \"FileOffset\" ] replacements = diag_results [ \"DiagnosticMessage\" ][ \"Replacements\" ] else : # prior to clang-tidy v9, the YML output was structured differently msg = diag_results [ \"Message\" ] offset = diag_results [ \"FileOffset\" ] replacements = diag_results [ \"Replacements\" ] diag . message = msg diag . line , diag . cols = get_line_cnt_from_cols ( yml [ \"MainSourceFile\" ], offset ) for replacement in [] if replacements is None else replacements : line_cnt , cols = get_line_cnt_from_cols ( yml [ \"MainSourceFile\" ], replacement [ \"Offset\" ] ) fix = TidyReplacement ( line_cnt , cols , replacement [ \"Length\" ]) fix . text = bytes ( replacement [ \"ReplacementText\" ], encoding = \"utf-8\" ) if fix . text . startswith ( b \"header is missing header guard\" ): logger . debug ( \"filtering header guard suggestion (making relative to repo root)\" ) fix . text = fix . text . replace ( CWD_HEADER_GUARD , b \"\" ) diag . replacements . append ( fix ) fixit . diagnostics . append ( diag ) # filter out absolute header guards GlobalParser . tidy_advice . append ( fixit )","title":"parse_tidy_suggestions_yml()"},{"location":"API%20Reference/cpp_linter/","text":"Base module \u00b6 The Base module of the cpp_linter package. This holds the objects shared by multiple modules. GlobalParser \u00b6 Global variables specific to output parsers. Each element in each of the following attributes represents a clang-tool's output for 1 source file. Source code in cpp_linter/__init__.py class GlobalParser : \"\"\"Global variables specific to output parsers. Each element in each of the following attributes represents a clang-tool's output for 1 source file. \"\"\" tidy_notes = [] # type: List[TidyNotification] \"\"\"This can only be a `list` of type [`TidyNotification`][cpp_linter.clang_tidy.TidyNotification]\"\"\" tidy_advice = [] # type: List[YMLFixit] \"\"\"This can only be a `list` of type [`YMLFixit`][cpp_linter.clang_tidy_yml.YMLFixit]\"\"\" format_advice = [] # type: List[XMLFixit] \"\"\"This can only be a `list` of type [`XMLFixit`][cpp_linter.clang_format_xml.XMLFixit]\"\"\" format_advice = [] class-attribute \u00b6 This can only be a list of type XMLFixit tidy_advice = [] class-attribute \u00b6 This can only be a list of type YMLFixit tidy_notes = [] class-attribute \u00b6 This can only be a list of type TidyNotification Globals \u00b6 Global variables for re-use (non-constant). Source code in cpp_linter/__init__.py class Globals : \"\"\"Global variables for re-use (non-constant).\"\"\" PAYLOAD_TIDY : str = \"\" \"\"\"The accumulated output of clang-tidy (gets appended to OUTPUT)\"\"\" OUTPUT : str = \"\" \"\"\"The accumulated body of the resulting comment that gets posted.\"\"\" FILES : List [ Dict [ str , Any ]] = [] \"\"\"The responding payload containing info about changed files.\"\"\" EVENT_PAYLOAD : Dict [ str , Any ] = {} \"\"\"The parsed JSON of the event payload.\"\"\" response_buffer = Response () \"\"\"A shared response object for `requests` module.\"\"\" EVENT_PAYLOAD : Dict [ str , Any ] = {} class-attribute \u00b6 The parsed JSON of the event payload. FILES : List [ Dict [ str , Any ]] = [] class-attribute \u00b6 The responding payload containing info about changed files. OUTPUT : str = '' class-attribute \u00b6 The accumulated body of the resulting comment that gets posted. PAYLOAD_TIDY : str = '' class-attribute \u00b6 The accumulated output of clang-tidy (gets appended to OUTPUT) response_buffer = Response () class-attribute \u00b6 A shared response object for requests module. assemble_version_exec ( tool_name : str , specified_version : str ) -> str \u00b6 Assembles the command to the executable of the given clang tool based on given version information. Parameters: Name Type Description Default tool_name str The name of the clang tool to be executed. required specified_version str The version number or the installed path to a version of the tool's executable. required Source code in cpp_linter/__init__.py def assemble_version_exec ( tool_name : str , specified_version : str ) -> str : \"\"\"Assembles the command to the executable of the given clang tool based on given version information. Args: tool_name: The name of the clang tool to be executed. specified_version: The version number or the installed path to a version of the tool's executable. \"\"\" suffix = \".exe\" if IS_ON_WINDOWS else \"\" if specified_version . isdigit (): # version info is not a path # let's assume the exe is in the PATH env var if IS_ON_WINDOWS : # installs don't usually append version number to exe name on Windows return f \" { tool_name }{ suffix } \" # omit version number return f \" { tool_name } - { specified_version }{ suffix } \" version_path = Path ( specified_version ) . resolve () # make absolute for path in [ # if installed via KyleMayes/install-llvm-action using the `directory` option version_path / \"bin\" / ( tool_name + suffix ), # if installed via clang-tools-pip pkg using the `-d` option version_path / ( tool_name + suffix ), ]: if path . exists (): return str ( path ) return tool_name + suffix get_line_cnt_from_cols ( file_path : str , offset : int ) -> tuple \u00b6 Gets a line count and columns offset from a file's absolute offset. Parameters: Name Type Description Default file_path str Path to file. required offset int The byte offset to translate required Returns: Type Description tuple A tuple of 2 int numbers: tuple Index 0 is the line number for the given offset. tuple Index 1 is the column number for the given offset on the line. Source code in cpp_linter/__init__.py def get_line_cnt_from_cols ( file_path : str , offset : int ) -> tuple : \"\"\"Gets a line count and columns offset from a file's absolute offset. Args: file_path: Path to file. offset: The byte offset to translate Returns: A `tuple` of 2 `int` numbers: - Index 0 is the line number for the given offset. - Index 1 is the column number for the given offset on the line. \"\"\" # logger.debug(\"Getting line count from %s at offset %d\", file_path, offset) contents = Path ( file_path ) . read_bytes ()[: offset ] return ( contents . count ( b \" \\n \" ) + 1 , offset - contents . rfind ( b \" \\n \" )) log_response_msg () -> bool \u00b6 Output the response buffer's message on a failed request. Returns: Type Description bool A bool describing if response's status code was less than 400. Source code in cpp_linter/__init__.py def log_response_msg () -> bool : \"\"\"Output the response buffer's message on a failed request. Returns: A bool describing if response's status code was less than 400. \"\"\" if Globals . response_buffer . status_code >= 400 : logger . error ( \"response returned %d message: %s \" , Globals . response_buffer . status_code , Globals . response_buffer . text , ) return False return True range_of_changed_lines ( file_obj : Dict [ str , Any ], lines_changed_only : int ) -> List [ int ] \u00b6 Assemble a list of lines changed. Parameters: Name Type Description Default file_obj Dict [ str , Any ] The file's JSON object. required lines_changed_only int A flag to indicate the focus of certain lines. 0: focuses on all lines in file. 1: focuses on any lines shown in the event's diff (may include unchanged lines). 2: focuses strictly on lines in the diff that contain additions. required Returns: Type Description List [ int ] A list of line numbers for which to give attention. Source code in cpp_linter/__init__.py def range_of_changed_lines ( file_obj : Dict [ str , Any ], lines_changed_only : int ) -> List [ int ]: \"\"\"Assemble a list of lines changed. Args: file_obj: The file's JSON object. lines_changed_only: A flag to indicate the focus of certain lines. - 0: focuses on all lines in file. - 1: focuses on any lines shown in the event's diff (may include unchanged lines). - 2: focuses strictly on lines in the diff that contain additions. Returns: A list of line numbers for which to give attention. \"\"\" if lines_changed_only : ranges = file_obj [ \"line_filter\" ][ \"diff_chunks\" if lines_changed_only == 1 else \"lines_added\" ] return [ l for r in ranges for l in range ( r [ 0 ], r [ 1 ])] return []","title":"Base module"},{"location":"API%20Reference/cpp_linter/#base-module","text":"The Base module of the cpp_linter package. This holds the objects shared by multiple modules.","title":"Base module"},{"location":"API%20Reference/cpp_linter/#cpp_linter.GlobalParser","text":"Global variables specific to output parsers. Each element in each of the following attributes represents a clang-tool's output for 1 source file. Source code in cpp_linter/__init__.py class GlobalParser : \"\"\"Global variables specific to output parsers. Each element in each of the following attributes represents a clang-tool's output for 1 source file. \"\"\" tidy_notes = [] # type: List[TidyNotification] \"\"\"This can only be a `list` of type [`TidyNotification`][cpp_linter.clang_tidy.TidyNotification]\"\"\" tidy_advice = [] # type: List[YMLFixit] \"\"\"This can only be a `list` of type [`YMLFixit`][cpp_linter.clang_tidy_yml.YMLFixit]\"\"\" format_advice = [] # type: List[XMLFixit] \"\"\"This can only be a `list` of type [`XMLFixit`][cpp_linter.clang_format_xml.XMLFixit]\"\"\"","title":"GlobalParser"},{"location":"API%20Reference/cpp_linter/#cpp_linter.GlobalParser.format_advice","text":"This can only be a list of type XMLFixit","title":"format_advice"},{"location":"API%20Reference/cpp_linter/#cpp_linter.GlobalParser.tidy_advice","text":"This can only be a list of type YMLFixit","title":"tidy_advice"},{"location":"API%20Reference/cpp_linter/#cpp_linter.GlobalParser.tidy_notes","text":"This can only be a list of type TidyNotification","title":"tidy_notes"},{"location":"API%20Reference/cpp_linter/#cpp_linter.Globals","text":"Global variables for re-use (non-constant). Source code in cpp_linter/__init__.py class Globals : \"\"\"Global variables for re-use (non-constant).\"\"\" PAYLOAD_TIDY : str = \"\" \"\"\"The accumulated output of clang-tidy (gets appended to OUTPUT)\"\"\" OUTPUT : str = \"\" \"\"\"The accumulated body of the resulting comment that gets posted.\"\"\" FILES : List [ Dict [ str , Any ]] = [] \"\"\"The responding payload containing info about changed files.\"\"\" EVENT_PAYLOAD : Dict [ str , Any ] = {} \"\"\"The parsed JSON of the event payload.\"\"\" response_buffer = Response () \"\"\"A shared response object for `requests` module.\"\"\"","title":"Globals"},{"location":"API%20Reference/cpp_linter/#cpp_linter.Globals.EVENT_PAYLOAD","text":"The parsed JSON of the event payload.","title":"EVENT_PAYLOAD"},{"location":"API%20Reference/cpp_linter/#cpp_linter.Globals.FILES","text":"The responding payload containing info about changed files.","title":"FILES"},{"location":"API%20Reference/cpp_linter/#cpp_linter.Globals.OUTPUT","text":"The accumulated body of the resulting comment that gets posted.","title":"OUTPUT"},{"location":"API%20Reference/cpp_linter/#cpp_linter.Globals.PAYLOAD_TIDY","text":"The accumulated output of clang-tidy (gets appended to OUTPUT)","title":"PAYLOAD_TIDY"},{"location":"API%20Reference/cpp_linter/#cpp_linter.Globals.response_buffer","text":"A shared response object for requests module.","title":"response_buffer"},{"location":"API%20Reference/cpp_linter/#cpp_linter.assemble_version_exec","text":"Assembles the command to the executable of the given clang tool based on given version information. Parameters: Name Type Description Default tool_name str The name of the clang tool to be executed. required specified_version str The version number or the installed path to a version of the tool's executable. required Source code in cpp_linter/__init__.py def assemble_version_exec ( tool_name : str , specified_version : str ) -> str : \"\"\"Assembles the command to the executable of the given clang tool based on given version information. Args: tool_name: The name of the clang tool to be executed. specified_version: The version number or the installed path to a version of the tool's executable. \"\"\" suffix = \".exe\" if IS_ON_WINDOWS else \"\" if specified_version . isdigit (): # version info is not a path # let's assume the exe is in the PATH env var if IS_ON_WINDOWS : # installs don't usually append version number to exe name on Windows return f \" { tool_name }{ suffix } \" # omit version number return f \" { tool_name } - { specified_version }{ suffix } \" version_path = Path ( specified_version ) . resolve () # make absolute for path in [ # if installed via KyleMayes/install-llvm-action using the `directory` option version_path / \"bin\" / ( tool_name + suffix ), # if installed via clang-tools-pip pkg using the `-d` option version_path / ( tool_name + suffix ), ]: if path . exists (): return str ( path ) return tool_name + suffix","title":"assemble_version_exec()"},{"location":"API%20Reference/cpp_linter/#cpp_linter.get_line_cnt_from_cols","text":"Gets a line count and columns offset from a file's absolute offset. Parameters: Name Type Description Default file_path str Path to file. required offset int The byte offset to translate required Returns: Type Description tuple A tuple of 2 int numbers: tuple Index 0 is the line number for the given offset. tuple Index 1 is the column number for the given offset on the line. Source code in cpp_linter/__init__.py def get_line_cnt_from_cols ( file_path : str , offset : int ) -> tuple : \"\"\"Gets a line count and columns offset from a file's absolute offset. Args: file_path: Path to file. offset: The byte offset to translate Returns: A `tuple` of 2 `int` numbers: - Index 0 is the line number for the given offset. - Index 1 is the column number for the given offset on the line. \"\"\" # logger.debug(\"Getting line count from %s at offset %d\", file_path, offset) contents = Path ( file_path ) . read_bytes ()[: offset ] return ( contents . count ( b \" \\n \" ) + 1 , offset - contents . rfind ( b \" \\n \" ))","title":"get_line_cnt_from_cols()"},{"location":"API%20Reference/cpp_linter/#cpp_linter.log_response_msg","text":"Output the response buffer's message on a failed request. Returns: Type Description bool A bool describing if response's status code was less than 400. Source code in cpp_linter/__init__.py def log_response_msg () -> bool : \"\"\"Output the response buffer's message on a failed request. Returns: A bool describing if response's status code was less than 400. \"\"\" if Globals . response_buffer . status_code >= 400 : logger . error ( \"response returned %d message: %s \" , Globals . response_buffer . status_code , Globals . response_buffer . text , ) return False return True","title":"log_response_msg()"},{"location":"API%20Reference/cpp_linter/#cpp_linter.range_of_changed_lines","text":"Assemble a list of lines changed. Parameters: Name Type Description Default file_obj Dict [ str , Any ] The file's JSON object. required lines_changed_only int A flag to indicate the focus of certain lines. 0: focuses on all lines in file. 1: focuses on any lines shown in the event's diff (may include unchanged lines). 2: focuses strictly on lines in the diff that contain additions. required Returns: Type Description List [ int ] A list of line numbers for which to give attention. Source code in cpp_linter/__init__.py def range_of_changed_lines ( file_obj : Dict [ str , Any ], lines_changed_only : int ) -> List [ int ]: \"\"\"Assemble a list of lines changed. Args: file_obj: The file's JSON object. lines_changed_only: A flag to indicate the focus of certain lines. - 0: focuses on all lines in file. - 1: focuses on any lines shown in the event's diff (may include unchanged lines). - 2: focuses strictly on lines in the diff that contain additions. Returns: A list of line numbers for which to give attention. \"\"\" if lines_changed_only : ranges = file_obj [ \"line_filter\" ][ \"diff_chunks\" if lines_changed_only == 1 else \"lines_added\" ] return [ l for r in ranges for l in range ( r [ 0 ], r [ 1 ])] return []","title":"range_of_changed_lines()"},{"location":"API%20Reference/cpp_linter.run/","text":"Run module \u00b6 Run clang-tidy and clang-format on a list of changed files provided by GitHub's REST API. If executed from command-line, then main() is the entrypoint. See Also github rest API reference for pulls github rest API reference for repos github rest API reference for issues capture_clang_tools_output ( version : str , checks : str , style : str , lines_changed_only : int , database : str , repo_root : str ) \u00b6 Execute and capture all output from clang-tidy and clang-format. This aggregates results in the OUTPUT . Parameters: Name Type Description Default version str The version of clang-tidy to run. required checks str The str of comma-separated regulate expressions that describe the desired clang-tidy checks to be enabled/configured. required style str The clang-format style rules to adhere. Set this to 'file' to use the relative-most .clang-format configuration file. required lines_changed_only int A flag that forces focus on only changes in the event's diff info. required Source code in cpp_linter/run.py def capture_clang_tools_output ( version : str , checks : str , style : str , lines_changed_only : int , database : str , repo_root : str , ): \"\"\"Execute and capture all output from clang-tidy and clang-format. This aggregates results in the [`OUTPUT`][cpp_linter.Globals.OUTPUT]. Args: version: The version of clang-tidy to run. checks: The `str` of comma-separated regulate expressions that describe the desired clang-tidy checks to be enabled/configured. style: The clang-format style rules to adhere. Set this to 'file' to use the relative-most .clang-format configuration file. lines_changed_only: A flag that forces focus on only changes in the event's diff info. \"\"\" # temporary cache of parsed notifications for use in log commands tidy_notes : List [ TidyNotification ] = [] for file in Globals . FILES : filename = cast ( str , file [ \"filename\" ]) start_log_group ( f \"Performing checkup on { filename } \" ) run_clang_tidy ( filename , file , version , checks , lines_changed_only , database , repo_root ) run_clang_format ( filename , file , version , style , lines_changed_only ) end_log_group () create_comment_body ( filename , file , lines_changed_only , tidy_notes ) if Globals . PAYLOAD_TIDY : if not Globals . OUTPUT : Globals . OUTPUT = \"<!-- cpp linter action --> \\n \" else : Globals . OUTPUT += \" \\n --- \\n \" Globals . OUTPUT += \"## :speech_balloon: Output from `clang-tidy` \\n \" Globals . OUTPUT += Globals . PAYLOAD_TIDY GlobalParser . tidy_notes = tidy_notes [:] # restore cache of notifications consolidate_list_to_ranges ( just_numbers : List [ int ]) -> List [ List [ int ]] \u00b6 A helper function to [ filter_out_non_source_files() ] that is only used when extracting the lines from a diff that contain additions. Source code in cpp_linter/run.py def consolidate_list_to_ranges ( just_numbers : List [ int ]) -> List [ List [ int ]]: \"\"\"A helper function to [`filter_out_non_source_files()`] that is only used when extracting the lines from a diff that contain additions.\"\"\" result : List [ List [ int ]] = [] for i , n in enumerate ( just_numbers ): if not i : result . append ([ n ]) elif n - 1 != just_numbers [ i - 1 ]: result [ - 1 ] . append ( just_numbers [ i - 1 ] + 1 ) result . append ([ n ]) if i == len ( just_numbers ) - 1 : result [ - 1 ] . append ( n + 1 ) return result create_comment_body ( filename : str , file_obj : Dict [ str , Any ], lines_changed_only : int , tidy_notes : List [ TidyNotification ]) \u00b6 Create the content for a thread comment about a certain file. This is a helper function to [ capture_clang_tools_output() ]. Parameters: Name Type Description Default filename str The file's name (& path). required file_obj Dict [ str , Any ] The file's JSON dict . required lines_changed_only int A flag used to filter the comment based on line changes. required tidy_notes List [ TidyNotification ] A list of cached notifications from clang-tidy. This is used to avoid duplicated content in comment, and it is later used again by [ make_annotations() ] after [ capture_clang_tools_output() ] us finished. required Source code in cpp_linter/run.py def create_comment_body ( filename : str , file_obj : Dict [ str , Any ], lines_changed_only : int , tidy_notes : List [ TidyNotification ], ): \"\"\"Create the content for a thread comment about a certain file. This is a helper function to [`capture_clang_tools_output()`]. Args: filename: The file's name (& path). file_obj: The file's JSON `dict`. lines_changed_only: A flag used to filter the comment based on line changes. tidy_notes: A list of cached notifications from clang-tidy. This is used to avoid duplicated content in comment, and it is later used again by [`make_annotations()`] after [`capture_clang_tools_output()`] us finished. \"\"\" ranges = range_of_changed_lines ( file_obj , lines_changed_only ) if Path ( \"clang_tidy_report.txt\" ) . stat () . st_size : parse_tidy_output () # get clang-tidy fixes from stdout comment_output = \"\" if Globals . PAYLOAD_TIDY : Globals . PAYLOAD_TIDY += \"<hr></details>\" for fix in GlobalParser . tidy_notes : if lines_changed_only and fix . line not in ranges : continue comment_output += repr ( fix ) tidy_notes . append ( fix ) if comment_output : Globals . PAYLOAD_TIDY += f \"<details><summary> { filename } </summary><br> \\n \" Globals . PAYLOAD_TIDY += comment_output GlobalParser . tidy_notes . clear () # empty list to avoid duplicated output if Path ( \"clang_format_output.xml\" ) . stat () . st_size : parse_format_replacements_xml ( PurePath ( filename ) . as_posix ()) if GlobalParser . format_advice and GlobalParser . format_advice [ - 1 ] . replaced_lines : should_comment = lines_changed_only == 0 if not should_comment : for line in [ replacement . line for replacement in GlobalParser . format_advice [ - 1 ] . replaced_lines ]: if line in ranges : should_comment = True break if should_comment : if not Globals . OUTPUT : Globals . OUTPUT = \"<!-- cpp linter action --> \\n ## :scroll: \" Globals . OUTPUT += \"Run `clang-format` on the following files \\n \" Globals . OUTPUT += f \"- [ ] { file_obj [ 'filename' ] } \\n \" end_log_group () -> None \u00b6 End a collapsable group of log statements. Source code in cpp_linter/run.py def end_log_group () -> None : \"\"\"End a collapsable group of log statements.\"\"\" log_commander . fatal ( \"::endgroup::\" ) filter_out_non_source_files ( ext_list : List [ str ], ignored : List [ str ], not_ignored : List [ str ]) -> bool \u00b6 Exclude undesired files (specified by user input 'extensions'). This filter applies to the event's FILES attribute. Parameters: Name Type Description Default ext_list List [ str ] A list of file extensions that are to be examined. required ignored List [ str ] A list of paths to explicitly ignore. required not_ignored List [ str ] A list of paths to explicitly not ignore. required Returns: Type Description bool True if there are files to check. False will invoke a early exit (in bool main() ) when no files to be checked. Source code in cpp_linter/run.py def filter_out_non_source_files ( ext_list : List [ str ], ignored : List [ str ], not_ignored : List [ str ], ) -> bool : \"\"\"Exclude undesired files (specified by user input 'extensions'). This filter applies to the event's [`FILES`][cpp_linter.Globals.FILES] attribute. Args: ext_list: A list of file extensions that are to be examined. ignored: A list of paths to explicitly ignore. not_ignored: A list of paths to explicitly not ignore. Returns: True if there are files to check. False will invoke a early exit (in [`main()`][cpp_linter.run.main]) when no files to be checked. \"\"\" files = [] for file in Globals . FILES : if ( PurePath ( file [ \"filename\" ]) . suffix . lstrip ( \".\" ) in ext_list and not file [ \"status\" ] . endswith ( \"removed\" ) and ( not is_file_in_list ( ignored , file [ \"filename\" ], \"ignored\" ) or is_file_in_list ( not_ignored , file [ \"filename\" ], \"not ignored\" ) ) ): if \"patch\" in file . keys (): # get diff details for the file's changes # ranges is a list of start/end line numbers shown in the diff ranges : List [ List [ int ]] = [] # additions is a list line numbers in the diff containing additions additions : List [ int ] = [] line_numb_in_diff : int = 0 for line in cast ( str , file [ \"patch\" ]) . splitlines (): if line . startswith ( \"+\" ): additions . append ( line_numb_in_diff ) if line . startswith ( \"@@ -\" ): hunk = line [ line . find ( \" +\" ) + 2 : line . find ( \" @@\" )] . split ( \",\" ) start_line , hunk_length = [ int ( x ) for x in hunk ] ranges . append ([ start_line , hunk_length + start_line ]) line_numb_in_diff = start_line elif not line . startswith ( \"-\" ): line_numb_in_diff += 1 file [ \"line_filter\" ] = dict ( diff_chunks = ranges , lines_added = consolidate_list_to_ranges ( additions ), ) files . append ( file ) if files : logger . info ( \"Giving attention to the following files: \\n\\t %s \" , \" \\n\\t \" . join ([ f [ \"filename\" ] for f in files ]), ) Globals . FILES = files if not IS_ON_RUNNER : # if not executed on a github runner # dump altered json of changed files Path ( \".changed_files.json\" ) . write_text ( json . dumps ( Globals . FILES , indent = 2 ), encoding = \"utf-8\" , ) else : logger . info ( \"No source files need checking!\" ) return False return True get_list_of_changed_files () -> None \u00b6 Fetch the JSON payload of the event's changed files. Sets the FILES attribute. Source code in cpp_linter/run.py def get_list_of_changed_files () -> None : \"\"\"Fetch the JSON payload of the event's changed files. Sets the [`FILES`][cpp_linter.Globals.FILES] attribute.\"\"\" start_log_group ( \"Get list of specified source files\" ) files_link = f \" { GITHUB_API_URL } /repos/ { GITHUB_REPOSITORY } /\" if GITHUB_EVENT_NAME == \"pull_request\" : files_link += f \"pulls/ { Globals . EVENT_PAYLOAD [ 'number' ] } /files\" else : if GITHUB_EVENT_NAME != \"push\" : logger . warning ( \"Triggered on unsupported event ' %s '. Behaving like a push event.\" , GITHUB_EVENT_NAME , ) files_link += f \"commits/ { GITHUB_SHA } \" logger . info ( \"Fetching files list from url: %s \" , files_link ) Globals . response_buffer = requests . get ( files_link , headers = API_HEADERS ) log_response_msg () if GITHUB_EVENT_NAME == \"pull_request\" : Globals . FILES = Globals . response_buffer . json () else : Globals . FILES = Globals . response_buffer . json ()[ \"files\" ] is_file_in_list ( paths : List [ str ], file_name : str , prompt : str ) -> bool \u00b6 Determine if a file is specified in a list of paths and/or filenames. Parameters: Name Type Description Default paths List [ str ] A list of specified paths to compare with. This list can contain a specified file, but the file's path must be included as part of the filename. required file_name str The file's path & name being sought in the paths list. required prompt str A debugging prompt to use when the path is found in the list. required Returns: Type Description bool True if file_name is in the paths list. bool False if file_name is not in the paths list. Source code in cpp_linter/run.py def is_file_in_list ( paths : List [ str ], file_name : str , prompt : str ) -> bool : \"\"\"Determine if a file is specified in a list of paths and/or filenames. Args: paths: A list of specified paths to compare with. This list can contain a specified file, but the file's path must be included as part of the filename. file_name: The file's path & name being sought in the `paths` list. prompt: A debugging prompt to use when the path is found in the list. Returns: - True if `file_name` is in the `paths` list. - False if `file_name` is not in the `paths` list. \"\"\" for path in paths : result = os . path . commonpath ( [ PurePath ( path ) . as_posix (), PurePath ( file_name ) . as_posix ()] ) if result == path : logger . debug ( '\"./ %s \" is %s as specified in the domain \"./ %s \"' , file_name , prompt , path , ) return True return False list_source_files ( ext_list : List [ str ], ignored_paths : List [ str ], not_ignored : List [ str ]) -> bool \u00b6 Make a list of source files to be checked. The resulting list is stored in FILES . Parameters: Name Type Description Default ext_list List [ str ] A list of file extensions that should by attended. required ignored_paths List [ str ] A list of paths to explicitly ignore. required not_ignored List [ str ] A list of paths to explicitly not ignore. required Returns: Type Description bool True if there are files to check. False will invoke a early exit (in bool main() ) when no files to be checked. Source code in cpp_linter/run.py def list_source_files ( ext_list : List [ str ], ignored_paths : List [ str ], not_ignored : List [ str ] ) -> bool : \"\"\"Make a list of source files to be checked. The resulting list is stored in [`FILES`][cpp_linter.Globals.FILES]. Args: ext_list: A list of file extensions that should by attended. ignored_paths: A list of paths to explicitly ignore. not_ignored: A list of paths to explicitly not ignore. Returns: True if there are files to check. False will invoke a early exit (in [`main()`][cpp_linter.run.main]) when no files to be checked. \"\"\" start_log_group ( \"Get list of specified source files\" ) root_path = Path ( \".\" ) for ext in ext_list : for rel_path in root_path . rglob ( f \"*. { ext } \" ): for parent in rel_path . parts [: - 1 ]: if parent . startswith ( \".\" ): break else : file_path = rel_path . as_posix () logger . debug ( '\"./ %s \" is a source code file' , file_path ) if not is_file_in_list ( ignored_paths , file_path , \"ignored\" ) or is_file_in_list ( not_ignored , file_path , \"not ignored\" ): Globals . FILES . append ( dict ( filename = file_path )) if Globals . FILES : logger . info ( \"Giving attention to the following files: \\n\\t %s \" , \" \\n\\t \" . join ([ f [ \"filename\" ] for f in Globals . FILES ]), ) else : logger . info ( \"No source files found.\" ) # this might need to be warning return False return True main () \u00b6 The main script. Source code in cpp_linter/run.py def main (): \"\"\"The main script.\"\"\" # The parsed CLI args args = cli_arg_parser . parse_args () # force files-changed-only to reflect value of lines-changed-only if args . lines_changed_only : args . files_changed_only = True # set logging verbosity logger . setLevel ( int ( args . verbosity )) # prepare ignored paths list ignored , not_ignored = parse_ignore_option ( args . ignore ) logger . info ( \"processing %s event\" , GITHUB_EVENT_NAME ) # change working directory os . chdir ( args . repo_root ) if GITHUB_EVENT_PATH : # load event's json info about the workflow run Globals . EVENT_PAYLOAD = json . loads ( Path ( GITHUB_EVENT_PATH ) . read_text ( encoding = \"utf-8\" ) ) if logger . getEffectiveLevel () <= logging . DEBUG : start_log_group ( \"Event json from the runner\" ) logger . debug ( json . dumps ( Globals . EVENT_PAYLOAD )) end_log_group () exit_early = False if args . files_changed_only : get_list_of_changed_files () exit_early = not filter_out_non_source_files ( args . extensions , ignored , not_ignored , ) if not exit_early : verify_files_are_present () else : exit_early = not list_source_files ( args . extensions , ignored , not_ignored ) end_log_group () if exit_early : sys . exit ( set_exit_code ( 0 )) capture_clang_tools_output ( args . version , args . tidy_checks , args . style , args . lines_changed_only , args . database , args . repo_root , ) start_log_group ( \"Posting comment(s)\" ) thread_comments_allowed = True if GITHUB_EVENT_PATH and \"private\" in Globals . EVENT_PAYLOAD [ \"repository\" ]: thread_comments_allowed = ( Globals . EVENT_PAYLOAD [ \"repository\" ][ \"private\" ] is not True ) if args . thread_comments and thread_comments_allowed : post_results ( False ) # False is hard-coded to disable diff comments. set_exit_code ( int ( make_annotations ( args . style , args . file_annotations , args . lines_changed_only ) ) ) end_log_group () make_annotations ( style : str , file_annotations : bool , lines_changed_only : int ) -> bool \u00b6 Use github log commands to make annotations from clang-format and clang-tidy output. Parameters: Name Type Description Default style str The chosen code style guidelines. The value 'file' is replaced with 'custom style'. required Source code in cpp_linter/run.py def make_annotations ( style : str , file_annotations : bool , lines_changed_only : int ) -> bool : \"\"\"Use github log commands to make annotations from clang-format and clang-tidy output. Args: style: The chosen code style guidelines. The value 'file' is replaced with 'custom style'. \"\"\" count = 0 files = ( Globals . FILES if GITHUB_EVENT_NAME == \"pull_request\" or isinstance ( Globals . FILES , list ) else cast ( Dict [ str , Any ], Globals . FILES )[ \"files\" ] ) for advice , file in zip ( GlobalParser . format_advice , files ): line_filter = range_of_changed_lines ( file , lines_changed_only ) if advice . replaced_lines : if file_annotations : output = advice . log_command ( style , line_filter ) if output is not None : log_commander . info ( output ) count += 1 for note in GlobalParser . tidy_notes : if lines_changed_only : filename = note . filename . replace ( \" \\\\ \" , \"/\" ) line_filter = [] for file in files : if filename == file [ \"filename\" ]: line_filter = range_of_changed_lines ( file , lines_changed_only ) break else : continue if note . line in line_filter : count += 1 log_commander . info ( note . log_command ()) else : count += 1 log_commander . info ( note . log_command ()) logger . info ( \"Created %d annotations\" , count ) return bool ( count ) parse_ignore_option ( paths : str ) -> Tuple [ List [ str ], List [ str ]] \u00b6 Parse a given string of paths (separated by a '|') into ignored and not_ignored lists of strings. Parameters: Name Type Description Default paths str This argument conforms to the CLI arg --ignore (or -i ). required Returns a tuple of lists in which each list is a set of strings. Type Description List [ str ] index 0 is the ignored list List [ str ] index 1 is the not_ignored list Source code in cpp_linter/run.py def parse_ignore_option ( paths : str ) -> Tuple [ List [ str ], List [ str ]]: \"\"\"Parse a given string of paths (separated by a '|') into `ignored` and `not_ignored` lists of strings. Args: paths: This argument conforms to the CLI arg `--ignore` (or `-i`). Returns: Returns a tuple of lists in which each list is a set of strings. index 0 is the `ignored` list index 1 is the `not_ignored` list \"\"\" ignored , not_ignored = ([], []) for path in paths . split ( \"|\" ): is_included = path . startswith ( \"!\" ) if path . startswith ( \"!./\" if is_included else \"./\" ): path = path . replace ( \"./\" , \"\" , 1 ) # relative dir is assumed path = path . strip () # strip leading/trailing spaces if is_included : not_ignored . append ( path [ 1 :]) # strip leading `!` else : ignored . append ( path ) # auto detect submodules gitmodules = Path ( \".gitmodules\" ) if gitmodules . exists (): submodules = configparser . ConfigParser () submodules . read ( gitmodules . resolve () . as_posix ()) for module in submodules . sections (): path = submodules [ module ][ \"path\" ] if path not in not_ignored : logger . info ( \"Appending submodule to ignored paths: %s \" , path ) ignored . append ( path ) if ignored : logger . info ( \"Ignoring the following paths/files: \\n\\t ./ %s \" , \" \\n\\t ./\" . join ( f for f in ignored ), ) if not_ignored : logger . info ( \"Not ignoring the following paths/files: \\n\\t ./ %s \" , \" \\n\\t ./\" . join ( f for f in not_ignored ), ) return ( ignored , not_ignored ) post_diff_comments ( base_url : str , user_id : int ) -> bool \u00b6 Post comments inside a unified diff (only PRs are supported). Parameters: Name Type Description Default base_url str The root of the url used to interact with the REST API via requests . required user_id int The user's account ID number. required Returns: Type Description bool A bool describing if the linter checks passed. This is used as the action's bool output value (a soft exit code). Source code in cpp_linter/run.py def post_diff_comments ( base_url : str , user_id : int ) -> bool : \"\"\"Post comments inside a unified diff (only PRs are supported). Args: base_url: The root of the url used to interact with the REST API via `requests`. user_id: The user's account ID number. Returns: A bool describing if the linter checks passed. This is used as the action's output value (a soft exit code). \"\"\" comments_url = base_url + \"pulls/comments/\" # for use with comment_id payload = list_diff_comments ( 2 ) # only focus on additions in diff logger . info ( \"Posting %d comments\" , len ( payload )) # uncomment the next 3 lines for debug output without posting a comment # for i, comment in enumerate(payload): # logger.debug(\"comments %d: %s\", i, json.dumps(comment, indent=2)) # return # get existing review comments reviews_url = base_url + f 'pulls/ { Globals . EVENT_PAYLOAD [ \"number\" ] } /' Globals . response_buffer = requests . get ( reviews_url + \"comments\" ) existing_comments = json . loads ( Globals . response_buffer . text ) # filter out comments not made by our bot for index , comment in enumerate ( existing_comments ): if not comment [ \"body\" ] . startswith ( \"<!-- cpp linter action -->\" ): del existing_comments [ index ] # conditionally post comments in the diff for i , body in enumerate ( payload ): # check if comment is already there already_posted = False comment_id = None for comment in existing_comments : if ( int ( comment [ \"user\" ][ \"id\" ]) == user_id and comment [ \"line\" ] == body [ \"line\" ] and comment [ \"path\" ] == body [ \"path\" ] ): already_posted = True if comment [ \"body\" ] != body [ \"body\" ]: comment_id = str ( comment [ \"id\" ]) # use this to update comment else : break if already_posted and comment_id is None : logger . info ( \"comment %d already posted\" , i ) continue # don't bother re-posting the same comment # update ot create a review comment (in the diff) logger . debug ( \"Payload %d body = %s \" , i , json . dumps ( body )) if comment_id is not None : Globals . response_buffer = requests . patch ( comments_url + comment_id , headers = API_HEADERS , data = json . dumps ({ \"body\" : body [ \"body\" ]}), ) logger . info ( \"Got %d from PATCHing comment %d ( %d )\" , Globals . response_buffer . status_code , i , comment_id , ) log_response_msg () else : Globals . response_buffer = requests . post ( reviews_url + \"comments\" , headers = API_HEADERS , data = json . dumps ( body ) ) logger . info ( \"Got %d from POSTing review comment %d \" , Globals . response_buffer . status_code , i , ) log_response_msg () return bool ( payload ) post_pr_comment ( base_url : str , user_id : int ) -> bool \u00b6 POST action's results for a push event. Parameters: Name Type Description Default base_url str The root of the url used to interact with the REST API via requests . required user_id int The user's account ID number. required Returns: Type Description bool A bool describing if the linter checks passed. This is used as the action's bool output value (a soft exit code). Source code in cpp_linter/run.py def post_pr_comment ( base_url : str , user_id : int ) -> bool : \"\"\"POST action's results for a push event. Args: base_url: The root of the url used to interact with the REST API via `requests`. user_id: The user's account ID number. Returns: A bool describing if the linter checks passed. This is used as the action's output value (a soft exit code). \"\"\" comments_url = base_url + f 'issues/ { Globals . EVENT_PAYLOAD [ \"number\" ] } /comments' remove_bot_comments ( comments_url , user_id ) payload = \"\" if Globals . OUTPUT : payload = json . dumps ({ \"body\" : Globals . OUTPUT }) logger . debug ( \"payload body: \\n %s \" , json . dumps ({ \"body\" : Globals . OUTPUT }, indent = 2 ) ) Globals . response_buffer = requests . post ( comments_url , headers = API_HEADERS , data = payload ) logger . info ( \"Got %d from POSTing comment\" , Globals . response_buffer . status_code ) log_response_msg () return bool ( payload ) post_push_comment ( base_url : str , user_id : int ) -> bool \u00b6 POST action's results for a push event. Parameters: Name Type Description Default base_url str The root of the url used to interact with the REST API via requests . required user_id int The user's account ID number. required Returns: Type Description bool A bool describing if the linter checks passed. This is used as the action's bool output value (a soft exit code). Source code in cpp_linter/run.py def post_push_comment ( base_url : str , user_id : int ) -> bool : \"\"\"POST action's results for a push event. Args: base_url: The root of the url used to interact with the REST API via `requests`. user_id: The user's account ID number. Returns: A bool describing if the linter checks passed. This is used as the action's output value (a soft exit code). \"\"\" comments_url = base_url + f \"commits/ { GITHUB_SHA } /comments\" remove_bot_comments ( comments_url , user_id ) if Globals . OUTPUT : # diff comments are not supported for push events (yet) payload = json . dumps ({ \"body\" : Globals . OUTPUT }) logger . debug ( \"payload body: \\n %s \" , json . dumps ({ \"body\" : Globals . OUTPUT })) Globals . response_buffer = requests . post ( comments_url , headers = API_HEADERS , data = payload ) logger . info ( \"Got %d response from POSTing comment\" , Globals . response_buffer . status_code ) log_response_msg () return bool ( Globals . OUTPUT ) post_results ( use_diff_comments : bool , user_id : int = 41898282 ) \u00b6 Post action's results using REST API. Parameters: Name Type Description Default use_diff_comments bool This flag enables making/updating comments in the PR's diff info. required user_id int The user's account ID number. Defaults to the generic bot's ID. 41898282 Source code in cpp_linter/run.py def post_results ( use_diff_comments : bool , user_id : int = 41898282 ): \"\"\"Post action's results using REST API. Args: use_diff_comments: This flag enables making/updating comments in the PR's diff info. user_id: The user's account ID number. Defaults to the generic bot's ID. \"\"\" if not GITHUB_TOKEN : logger . error ( \"The GITHUB_TOKEN is required!\" ) sys . exit ( set_exit_code ( 1 )) base_url = f \" { GITHUB_API_URL } /repos/ { GITHUB_REPOSITORY } /\" checks_passed = True if GITHUB_EVENT_NAME == \"pull_request\" : checks_passed = post_pr_comment ( base_url , user_id ) if use_diff_comments : checks_passed = post_diff_comments ( base_url , user_id ) elif GITHUB_EVENT_NAME == \"push\" : checks_passed = post_push_comment ( base_url , user_id ) set_exit_code ( 1 if checks_passed else 0 ) run_clang_format ( filename : str , file_obj : Dict [ str , Any ], version : str , style : str , lines_changed_only : int ) -> None \u00b6 Run clang-format on a certain file Parameters: Name Type Description Default filename str The name of the local file to run clang-format on. required file_obj Dict [ str , Any ] JSON info about the file. required version str The version of clang-format to run. required style str The clang-format style rules to adhere. Set this to 'file' to use the relative-most .clang-format configuration file. required lines_changed_only int A flag that forces focus on only changes in the event's diff info. required Source code in cpp_linter/run.py def run_clang_format ( filename : str , file_obj : Dict [ str , Any ], version : str , style : str , lines_changed_only : int , ) -> None : \"\"\"Run clang-format on a certain file Args: filename: The name of the local file to run clang-format on. file_obj: JSON info about the file. version: The version of clang-format to run. style: The clang-format style rules to adhere. Set this to 'file' to use the relative-most .clang-format configuration file. lines_changed_only: A flag that forces focus on only changes in the event's diff info. \"\"\" if not style : # if `style` == \"\" Path ( \"clang_format_output.xml\" ) . write_bytes ( b \"\" ) return # clear any previous output and exit cmds = [ assemble_version_exec ( \"clang-format\" , version ), f \"-style= { style } \" , \"--output-replacements-xml\" , ] if lines_changed_only : ranges = \"diff_chunks\" if lines_changed_only == 1 else \"lines_added\" for line_range in file_obj [ \"line_filter\" ][ ranges ]: cmds . append ( f \"--lines= { line_range [ 0 ] } : { line_range [ 1 ] } \" ) cmds . append ( PurePath ( filename ) . as_posix ()) logger . info ( 'Running \" %s \"' , \" \" . join ( cmds )) results = subprocess . run ( cmds , capture_output = True ) Path ( \"clang_format_output.xml\" ) . write_bytes ( results . stdout ) if results . returncode : logger . debug ( \" %s raised the following error(s): \\n %s \" , cmds [ 0 ], results . stderr . decode () ) run_clang_tidy ( filename : str , file_obj : Dict [ str , Any ], version : str , checks : str , lines_changed_only : int , database : str , repo_root : str ) -> None \u00b6 Run clang-tidy on a certain file. Parameters: Name Type Description Default filename str The name of the local file to run clang-tidy on. required file_obj Dict [ str , Any ] JSON info about the file. required version str The version of clang-tidy to run. required checks str The str of comma-separated regulate expressions that describe the desired clang-tidy checks to be enabled/configured. required lines_changed_only int A flag that forces focus on only changes in the event's diff info. required Source code in cpp_linter/run.py def run_clang_tidy ( filename : str , file_obj : Dict [ str , Any ], version : str , checks : str , lines_changed_only : int , database : str , repo_root : str , ) -> None : \"\"\"Run clang-tidy on a certain file. Args: filename: The name of the local file to run clang-tidy on. file_obj: JSON info about the file. version: The version of clang-tidy to run. checks: The `str` of comma-separated regulate expressions that describe the desired clang-tidy checks to be enabled/configured. lines_changed_only: A flag that forces focus on only changes in the event's diff info. \"\"\" if checks == \"-*\" : # if all checks are disabled, then clang-tidy is skipped # clear the clang-tidy output file and exit function Path ( \"clang_tidy_report.txt\" ) . write_bytes ( b \"\" ) return filename = PurePath ( filename ) . as_posix () cmds = [ assemble_version_exec ( \"clang-tidy\" , version ), \"--export-fixes=clang_tidy_output.yml\" , ] if checks : cmds . append ( f \"-checks= { checks } \" ) if database : cmds . append ( \"-p\" ) if not PurePath ( database ) . is_absolute (): database = str ( Path ( RUNNER_WORKSPACE , repo_root , database ) . resolve ()) cmds . append ( database ) if lines_changed_only : ranges = \"diff_chunks\" if lines_changed_only == 1 else \"lines_added\" line_ranges = dict ( name = filename , lines = file_obj [ \"line_filter\" ][ ranges ]) logger . info ( \"line_filter = %s \" , json . dumps ([ line_ranges ])) cmds . append ( f \"--line-filter= { json . dumps ([ line_ranges ]) } \" ) cmds . append ( filename ) # clear yml file's content before running clang-tidy Path ( \"clang_tidy_output.yml\" ) . write_bytes ( b \"\" ) logger . info ( 'Running \" %s \"' , \" \" . join ( cmds )) results = subprocess . run ( cmds , capture_output = True ) Path ( \"clang_tidy_report.txt\" ) . write_bytes ( results . stdout ) logger . debug ( \"Output from clang-tidy: \\n %s \" , results . stdout . decode ()) if Path ( \"clang_tidy_output.yml\" ) . stat () . st_size : parse_tidy_suggestions_yml () # get clang-tidy fixes from yml if results . stderr : logger . debug ( \"clang-tidy made the following summary: \\n %s \" , results . stderr . decode () ) set_exit_code ( override : int = None ) -> int \u00b6 Set the action's exit code. Parameters: Name Type Description Default override int The number to use when overriding the action's logic. None Returns: Type Description int The exit code that was used. If the override parameter was not passed, int then this value will describe (like a bool value) if any checks failed. Source code in cpp_linter/run.py def set_exit_code ( override : int = None ) -> int : \"\"\"Set the action's exit code. Args: override: The number to use when overriding the action's logic. Returns: The exit code that was used. If the `override` parameter was not passed, then this value will describe (like a bool value) if any checks failed. \"\"\" exit_code = override if override is not None else bool ( Globals . OUTPUT ) print ( f \"::set-output name=checks-failed:: { exit_code } \" ) return exit_code start_log_group ( name : str ) -> None \u00b6 Begin a collapsable group of log statements. Parameters: Name Type Description Default name str The name of the collapsable group required Source code in cpp_linter/run.py def start_log_group ( name : str ) -> None : \"\"\"Begin a collapsable group of log statements. Args: name: The name of the collapsable group \"\"\" log_commander . fatal ( \"::group:: %s \" , name ) verify_files_are_present () -> None \u00b6 Download the files if not present. Hint This function assumes the working directory is the root of the invoking repository. If files are not found, then they are downloaded to the working directory. This is bad for files with the same name from different folders. Source code in cpp_linter/run.py def verify_files_are_present () -> None : \"\"\"Download the files if not present. !!! hint This function assumes the working directory is the root of the invoking repository. If files are not found, then they are downloaded to the working directory. This is bad for files with the same name from different folders. \"\"\" for file in Globals . FILES : file_name = Path ( file [ \"filename\" ]) if not file_name . exists (): logger . warning ( \"Could not find %s ! Did you checkout the repo?\" , file_name ) logger . info ( \"Downloading file from url: %s \" , file [ \"raw_url\" ]) Globals . response_buffer = requests . get ( file [ \"raw_url\" ]) # retain the repo's original structure Path . mkdir ( file_name . parent , parents = True , exist_ok = True ) file_name . write_text ( Globals . response_buffer . text , encoding = \"utf-8\" )","title":"Run module"},{"location":"API%20Reference/cpp_linter.run/#run-module","text":"Run clang-tidy and clang-format on a list of changed files provided by GitHub's REST API. If executed from command-line, then main() is the entrypoint. See Also github rest API reference for pulls github rest API reference for repos github rest API reference for issues","title":"Run module"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.capture_clang_tools_output","text":"Execute and capture all output from clang-tidy and clang-format. This aggregates results in the OUTPUT . Parameters: Name Type Description Default version str The version of clang-tidy to run. required checks str The str of comma-separated regulate expressions that describe the desired clang-tidy checks to be enabled/configured. required style str The clang-format style rules to adhere. Set this to 'file' to use the relative-most .clang-format configuration file. required lines_changed_only int A flag that forces focus on only changes in the event's diff info. required Source code in cpp_linter/run.py def capture_clang_tools_output ( version : str , checks : str , style : str , lines_changed_only : int , database : str , repo_root : str , ): \"\"\"Execute and capture all output from clang-tidy and clang-format. This aggregates results in the [`OUTPUT`][cpp_linter.Globals.OUTPUT]. Args: version: The version of clang-tidy to run. checks: The `str` of comma-separated regulate expressions that describe the desired clang-tidy checks to be enabled/configured. style: The clang-format style rules to adhere. Set this to 'file' to use the relative-most .clang-format configuration file. lines_changed_only: A flag that forces focus on only changes in the event's diff info. \"\"\" # temporary cache of parsed notifications for use in log commands tidy_notes : List [ TidyNotification ] = [] for file in Globals . FILES : filename = cast ( str , file [ \"filename\" ]) start_log_group ( f \"Performing checkup on { filename } \" ) run_clang_tidy ( filename , file , version , checks , lines_changed_only , database , repo_root ) run_clang_format ( filename , file , version , style , lines_changed_only ) end_log_group () create_comment_body ( filename , file , lines_changed_only , tidy_notes ) if Globals . PAYLOAD_TIDY : if not Globals . OUTPUT : Globals . OUTPUT = \"<!-- cpp linter action --> \\n \" else : Globals . OUTPUT += \" \\n --- \\n \" Globals . OUTPUT += \"## :speech_balloon: Output from `clang-tidy` \\n \" Globals . OUTPUT += Globals . PAYLOAD_TIDY GlobalParser . tidy_notes = tidy_notes [:] # restore cache of notifications","title":"capture_clang_tools_output()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.consolidate_list_to_ranges","text":"A helper function to [ filter_out_non_source_files() ] that is only used when extracting the lines from a diff that contain additions. Source code in cpp_linter/run.py def consolidate_list_to_ranges ( just_numbers : List [ int ]) -> List [ List [ int ]]: \"\"\"A helper function to [`filter_out_non_source_files()`] that is only used when extracting the lines from a diff that contain additions.\"\"\" result : List [ List [ int ]] = [] for i , n in enumerate ( just_numbers ): if not i : result . append ([ n ]) elif n - 1 != just_numbers [ i - 1 ]: result [ - 1 ] . append ( just_numbers [ i - 1 ] + 1 ) result . append ([ n ]) if i == len ( just_numbers ) - 1 : result [ - 1 ] . append ( n + 1 ) return result","title":"consolidate_list_to_ranges()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.create_comment_body","text":"Create the content for a thread comment about a certain file. This is a helper function to [ capture_clang_tools_output() ]. Parameters: Name Type Description Default filename str The file's name (& path). required file_obj Dict [ str , Any ] The file's JSON dict . required lines_changed_only int A flag used to filter the comment based on line changes. required tidy_notes List [ TidyNotification ] A list of cached notifications from clang-tidy. This is used to avoid duplicated content in comment, and it is later used again by [ make_annotations() ] after [ capture_clang_tools_output() ] us finished. required Source code in cpp_linter/run.py def create_comment_body ( filename : str , file_obj : Dict [ str , Any ], lines_changed_only : int , tidy_notes : List [ TidyNotification ], ): \"\"\"Create the content for a thread comment about a certain file. This is a helper function to [`capture_clang_tools_output()`]. Args: filename: The file's name (& path). file_obj: The file's JSON `dict`. lines_changed_only: A flag used to filter the comment based on line changes. tidy_notes: A list of cached notifications from clang-tidy. This is used to avoid duplicated content in comment, and it is later used again by [`make_annotations()`] after [`capture_clang_tools_output()`] us finished. \"\"\" ranges = range_of_changed_lines ( file_obj , lines_changed_only ) if Path ( \"clang_tidy_report.txt\" ) . stat () . st_size : parse_tidy_output () # get clang-tidy fixes from stdout comment_output = \"\" if Globals . PAYLOAD_TIDY : Globals . PAYLOAD_TIDY += \"<hr></details>\" for fix in GlobalParser . tidy_notes : if lines_changed_only and fix . line not in ranges : continue comment_output += repr ( fix ) tidy_notes . append ( fix ) if comment_output : Globals . PAYLOAD_TIDY += f \"<details><summary> { filename } </summary><br> \\n \" Globals . PAYLOAD_TIDY += comment_output GlobalParser . tidy_notes . clear () # empty list to avoid duplicated output if Path ( \"clang_format_output.xml\" ) . stat () . st_size : parse_format_replacements_xml ( PurePath ( filename ) . as_posix ()) if GlobalParser . format_advice and GlobalParser . format_advice [ - 1 ] . replaced_lines : should_comment = lines_changed_only == 0 if not should_comment : for line in [ replacement . line for replacement in GlobalParser . format_advice [ - 1 ] . replaced_lines ]: if line in ranges : should_comment = True break if should_comment : if not Globals . OUTPUT : Globals . OUTPUT = \"<!-- cpp linter action --> \\n ## :scroll: \" Globals . OUTPUT += \"Run `clang-format` on the following files \\n \" Globals . OUTPUT += f \"- [ ] { file_obj [ 'filename' ] } \\n \"","title":"create_comment_body()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.end_log_group","text":"End a collapsable group of log statements. Source code in cpp_linter/run.py def end_log_group () -> None : \"\"\"End a collapsable group of log statements.\"\"\" log_commander . fatal ( \"::endgroup::\" )","title":"end_log_group()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.filter_out_non_source_files","text":"Exclude undesired files (specified by user input 'extensions'). This filter applies to the event's FILES attribute. Parameters: Name Type Description Default ext_list List [ str ] A list of file extensions that are to be examined. required ignored List [ str ] A list of paths to explicitly ignore. required not_ignored List [ str ] A list of paths to explicitly not ignore. required Returns: Type Description bool True if there are files to check. False will invoke a early exit (in bool main() ) when no files to be checked. Source code in cpp_linter/run.py def filter_out_non_source_files ( ext_list : List [ str ], ignored : List [ str ], not_ignored : List [ str ], ) -> bool : \"\"\"Exclude undesired files (specified by user input 'extensions'). This filter applies to the event's [`FILES`][cpp_linter.Globals.FILES] attribute. Args: ext_list: A list of file extensions that are to be examined. ignored: A list of paths to explicitly ignore. not_ignored: A list of paths to explicitly not ignore. Returns: True if there are files to check. False will invoke a early exit (in [`main()`][cpp_linter.run.main]) when no files to be checked. \"\"\" files = [] for file in Globals . FILES : if ( PurePath ( file [ \"filename\" ]) . suffix . lstrip ( \".\" ) in ext_list and not file [ \"status\" ] . endswith ( \"removed\" ) and ( not is_file_in_list ( ignored , file [ \"filename\" ], \"ignored\" ) or is_file_in_list ( not_ignored , file [ \"filename\" ], \"not ignored\" ) ) ): if \"patch\" in file . keys (): # get diff details for the file's changes # ranges is a list of start/end line numbers shown in the diff ranges : List [ List [ int ]] = [] # additions is a list line numbers in the diff containing additions additions : List [ int ] = [] line_numb_in_diff : int = 0 for line in cast ( str , file [ \"patch\" ]) . splitlines (): if line . startswith ( \"+\" ): additions . append ( line_numb_in_diff ) if line . startswith ( \"@@ -\" ): hunk = line [ line . find ( \" +\" ) + 2 : line . find ( \" @@\" )] . split ( \",\" ) start_line , hunk_length = [ int ( x ) for x in hunk ] ranges . append ([ start_line , hunk_length + start_line ]) line_numb_in_diff = start_line elif not line . startswith ( \"-\" ): line_numb_in_diff += 1 file [ \"line_filter\" ] = dict ( diff_chunks = ranges , lines_added = consolidate_list_to_ranges ( additions ), ) files . append ( file ) if files : logger . info ( \"Giving attention to the following files: \\n\\t %s \" , \" \\n\\t \" . join ([ f [ \"filename\" ] for f in files ]), ) Globals . FILES = files if not IS_ON_RUNNER : # if not executed on a github runner # dump altered json of changed files Path ( \".changed_files.json\" ) . write_text ( json . dumps ( Globals . FILES , indent = 2 ), encoding = \"utf-8\" , ) else : logger . info ( \"No source files need checking!\" ) return False return True","title":"filter_out_non_source_files()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.get_list_of_changed_files","text":"Fetch the JSON payload of the event's changed files. Sets the FILES attribute. Source code in cpp_linter/run.py def get_list_of_changed_files () -> None : \"\"\"Fetch the JSON payload of the event's changed files. Sets the [`FILES`][cpp_linter.Globals.FILES] attribute.\"\"\" start_log_group ( \"Get list of specified source files\" ) files_link = f \" { GITHUB_API_URL } /repos/ { GITHUB_REPOSITORY } /\" if GITHUB_EVENT_NAME == \"pull_request\" : files_link += f \"pulls/ { Globals . EVENT_PAYLOAD [ 'number' ] } /files\" else : if GITHUB_EVENT_NAME != \"push\" : logger . warning ( \"Triggered on unsupported event ' %s '. Behaving like a push event.\" , GITHUB_EVENT_NAME , ) files_link += f \"commits/ { GITHUB_SHA } \" logger . info ( \"Fetching files list from url: %s \" , files_link ) Globals . response_buffer = requests . get ( files_link , headers = API_HEADERS ) log_response_msg () if GITHUB_EVENT_NAME == \"pull_request\" : Globals . FILES = Globals . response_buffer . json () else : Globals . FILES = Globals . response_buffer . json ()[ \"files\" ]","title":"get_list_of_changed_files()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.is_file_in_list","text":"Determine if a file is specified in a list of paths and/or filenames. Parameters: Name Type Description Default paths List [ str ] A list of specified paths to compare with. This list can contain a specified file, but the file's path must be included as part of the filename. required file_name str The file's path & name being sought in the paths list. required prompt str A debugging prompt to use when the path is found in the list. required Returns: Type Description bool True if file_name is in the paths list. bool False if file_name is not in the paths list. Source code in cpp_linter/run.py def is_file_in_list ( paths : List [ str ], file_name : str , prompt : str ) -> bool : \"\"\"Determine if a file is specified in a list of paths and/or filenames. Args: paths: A list of specified paths to compare with. This list can contain a specified file, but the file's path must be included as part of the filename. file_name: The file's path & name being sought in the `paths` list. prompt: A debugging prompt to use when the path is found in the list. Returns: - True if `file_name` is in the `paths` list. - False if `file_name` is not in the `paths` list. \"\"\" for path in paths : result = os . path . commonpath ( [ PurePath ( path ) . as_posix (), PurePath ( file_name ) . as_posix ()] ) if result == path : logger . debug ( '\"./ %s \" is %s as specified in the domain \"./ %s \"' , file_name , prompt , path , ) return True return False","title":"is_file_in_list()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.list_source_files","text":"Make a list of source files to be checked. The resulting list is stored in FILES . Parameters: Name Type Description Default ext_list List [ str ] A list of file extensions that should by attended. required ignored_paths List [ str ] A list of paths to explicitly ignore. required not_ignored List [ str ] A list of paths to explicitly not ignore. required Returns: Type Description bool True if there are files to check. False will invoke a early exit (in bool main() ) when no files to be checked. Source code in cpp_linter/run.py def list_source_files ( ext_list : List [ str ], ignored_paths : List [ str ], not_ignored : List [ str ] ) -> bool : \"\"\"Make a list of source files to be checked. The resulting list is stored in [`FILES`][cpp_linter.Globals.FILES]. Args: ext_list: A list of file extensions that should by attended. ignored_paths: A list of paths to explicitly ignore. not_ignored: A list of paths to explicitly not ignore. Returns: True if there are files to check. False will invoke a early exit (in [`main()`][cpp_linter.run.main]) when no files to be checked. \"\"\" start_log_group ( \"Get list of specified source files\" ) root_path = Path ( \".\" ) for ext in ext_list : for rel_path in root_path . rglob ( f \"*. { ext } \" ): for parent in rel_path . parts [: - 1 ]: if parent . startswith ( \".\" ): break else : file_path = rel_path . as_posix () logger . debug ( '\"./ %s \" is a source code file' , file_path ) if not is_file_in_list ( ignored_paths , file_path , \"ignored\" ) or is_file_in_list ( not_ignored , file_path , \"not ignored\" ): Globals . FILES . append ( dict ( filename = file_path )) if Globals . FILES : logger . info ( \"Giving attention to the following files: \\n\\t %s \" , \" \\n\\t \" . join ([ f [ \"filename\" ] for f in Globals . FILES ]), ) else : logger . info ( \"No source files found.\" ) # this might need to be warning return False return True","title":"list_source_files()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.main","text":"The main script. Source code in cpp_linter/run.py def main (): \"\"\"The main script.\"\"\" # The parsed CLI args args = cli_arg_parser . parse_args () # force files-changed-only to reflect value of lines-changed-only if args . lines_changed_only : args . files_changed_only = True # set logging verbosity logger . setLevel ( int ( args . verbosity )) # prepare ignored paths list ignored , not_ignored = parse_ignore_option ( args . ignore ) logger . info ( \"processing %s event\" , GITHUB_EVENT_NAME ) # change working directory os . chdir ( args . repo_root ) if GITHUB_EVENT_PATH : # load event's json info about the workflow run Globals . EVENT_PAYLOAD = json . loads ( Path ( GITHUB_EVENT_PATH ) . read_text ( encoding = \"utf-8\" ) ) if logger . getEffectiveLevel () <= logging . DEBUG : start_log_group ( \"Event json from the runner\" ) logger . debug ( json . dumps ( Globals . EVENT_PAYLOAD )) end_log_group () exit_early = False if args . files_changed_only : get_list_of_changed_files () exit_early = not filter_out_non_source_files ( args . extensions , ignored , not_ignored , ) if not exit_early : verify_files_are_present () else : exit_early = not list_source_files ( args . extensions , ignored , not_ignored ) end_log_group () if exit_early : sys . exit ( set_exit_code ( 0 )) capture_clang_tools_output ( args . version , args . tidy_checks , args . style , args . lines_changed_only , args . database , args . repo_root , ) start_log_group ( \"Posting comment(s)\" ) thread_comments_allowed = True if GITHUB_EVENT_PATH and \"private\" in Globals . EVENT_PAYLOAD [ \"repository\" ]: thread_comments_allowed = ( Globals . EVENT_PAYLOAD [ \"repository\" ][ \"private\" ] is not True ) if args . thread_comments and thread_comments_allowed : post_results ( False ) # False is hard-coded to disable diff comments. set_exit_code ( int ( make_annotations ( args . style , args . file_annotations , args . lines_changed_only ) ) ) end_log_group ()","title":"main()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.make_annotations","text":"Use github log commands to make annotations from clang-format and clang-tidy output. Parameters: Name Type Description Default style str The chosen code style guidelines. The value 'file' is replaced with 'custom style'. required Source code in cpp_linter/run.py def make_annotations ( style : str , file_annotations : bool , lines_changed_only : int ) -> bool : \"\"\"Use github log commands to make annotations from clang-format and clang-tidy output. Args: style: The chosen code style guidelines. The value 'file' is replaced with 'custom style'. \"\"\" count = 0 files = ( Globals . FILES if GITHUB_EVENT_NAME == \"pull_request\" or isinstance ( Globals . FILES , list ) else cast ( Dict [ str , Any ], Globals . FILES )[ \"files\" ] ) for advice , file in zip ( GlobalParser . format_advice , files ): line_filter = range_of_changed_lines ( file , lines_changed_only ) if advice . replaced_lines : if file_annotations : output = advice . log_command ( style , line_filter ) if output is not None : log_commander . info ( output ) count += 1 for note in GlobalParser . tidy_notes : if lines_changed_only : filename = note . filename . replace ( \" \\\\ \" , \"/\" ) line_filter = [] for file in files : if filename == file [ \"filename\" ]: line_filter = range_of_changed_lines ( file , lines_changed_only ) break else : continue if note . line in line_filter : count += 1 log_commander . info ( note . log_command ()) else : count += 1 log_commander . info ( note . log_command ()) logger . info ( \"Created %d annotations\" , count ) return bool ( count )","title":"make_annotations()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.parse_ignore_option","text":"Parse a given string of paths (separated by a '|') into ignored and not_ignored lists of strings. Parameters: Name Type Description Default paths str This argument conforms to the CLI arg --ignore (or -i ). required Returns a tuple of lists in which each list is a set of strings. Type Description List [ str ] index 0 is the ignored list List [ str ] index 1 is the not_ignored list Source code in cpp_linter/run.py def parse_ignore_option ( paths : str ) -> Tuple [ List [ str ], List [ str ]]: \"\"\"Parse a given string of paths (separated by a '|') into `ignored` and `not_ignored` lists of strings. Args: paths: This argument conforms to the CLI arg `--ignore` (or `-i`). Returns: Returns a tuple of lists in which each list is a set of strings. index 0 is the `ignored` list index 1 is the `not_ignored` list \"\"\" ignored , not_ignored = ([], []) for path in paths . split ( \"|\" ): is_included = path . startswith ( \"!\" ) if path . startswith ( \"!./\" if is_included else \"./\" ): path = path . replace ( \"./\" , \"\" , 1 ) # relative dir is assumed path = path . strip () # strip leading/trailing spaces if is_included : not_ignored . append ( path [ 1 :]) # strip leading `!` else : ignored . append ( path ) # auto detect submodules gitmodules = Path ( \".gitmodules\" ) if gitmodules . exists (): submodules = configparser . ConfigParser () submodules . read ( gitmodules . resolve () . as_posix ()) for module in submodules . sections (): path = submodules [ module ][ \"path\" ] if path not in not_ignored : logger . info ( \"Appending submodule to ignored paths: %s \" , path ) ignored . append ( path ) if ignored : logger . info ( \"Ignoring the following paths/files: \\n\\t ./ %s \" , \" \\n\\t ./\" . join ( f for f in ignored ), ) if not_ignored : logger . info ( \"Not ignoring the following paths/files: \\n\\t ./ %s \" , \" \\n\\t ./\" . join ( f for f in not_ignored ), ) return ( ignored , not_ignored )","title":"parse_ignore_option()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.post_diff_comments","text":"Post comments inside a unified diff (only PRs are supported). Parameters: Name Type Description Default base_url str The root of the url used to interact with the REST API via requests . required user_id int The user's account ID number. required Returns: Type Description bool A bool describing if the linter checks passed. This is used as the action's bool output value (a soft exit code). Source code in cpp_linter/run.py def post_diff_comments ( base_url : str , user_id : int ) -> bool : \"\"\"Post comments inside a unified diff (only PRs are supported). Args: base_url: The root of the url used to interact with the REST API via `requests`. user_id: The user's account ID number. Returns: A bool describing if the linter checks passed. This is used as the action's output value (a soft exit code). \"\"\" comments_url = base_url + \"pulls/comments/\" # for use with comment_id payload = list_diff_comments ( 2 ) # only focus on additions in diff logger . info ( \"Posting %d comments\" , len ( payload )) # uncomment the next 3 lines for debug output without posting a comment # for i, comment in enumerate(payload): # logger.debug(\"comments %d: %s\", i, json.dumps(comment, indent=2)) # return # get existing review comments reviews_url = base_url + f 'pulls/ { Globals . EVENT_PAYLOAD [ \"number\" ] } /' Globals . response_buffer = requests . get ( reviews_url + \"comments\" ) existing_comments = json . loads ( Globals . response_buffer . text ) # filter out comments not made by our bot for index , comment in enumerate ( existing_comments ): if not comment [ \"body\" ] . startswith ( \"<!-- cpp linter action -->\" ): del existing_comments [ index ] # conditionally post comments in the diff for i , body in enumerate ( payload ): # check if comment is already there already_posted = False comment_id = None for comment in existing_comments : if ( int ( comment [ \"user\" ][ \"id\" ]) == user_id and comment [ \"line\" ] == body [ \"line\" ] and comment [ \"path\" ] == body [ \"path\" ] ): already_posted = True if comment [ \"body\" ] != body [ \"body\" ]: comment_id = str ( comment [ \"id\" ]) # use this to update comment else : break if already_posted and comment_id is None : logger . info ( \"comment %d already posted\" , i ) continue # don't bother re-posting the same comment # update ot create a review comment (in the diff) logger . debug ( \"Payload %d body = %s \" , i , json . dumps ( body )) if comment_id is not None : Globals . response_buffer = requests . patch ( comments_url + comment_id , headers = API_HEADERS , data = json . dumps ({ \"body\" : body [ \"body\" ]}), ) logger . info ( \"Got %d from PATCHing comment %d ( %d )\" , Globals . response_buffer . status_code , i , comment_id , ) log_response_msg () else : Globals . response_buffer = requests . post ( reviews_url + \"comments\" , headers = API_HEADERS , data = json . dumps ( body ) ) logger . info ( \"Got %d from POSTing review comment %d \" , Globals . response_buffer . status_code , i , ) log_response_msg () return bool ( payload )","title":"post_diff_comments()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.post_pr_comment","text":"POST action's results for a push event. Parameters: Name Type Description Default base_url str The root of the url used to interact with the REST API via requests . required user_id int The user's account ID number. required Returns: Type Description bool A bool describing if the linter checks passed. This is used as the action's bool output value (a soft exit code). Source code in cpp_linter/run.py def post_pr_comment ( base_url : str , user_id : int ) -> bool : \"\"\"POST action's results for a push event. Args: base_url: The root of the url used to interact with the REST API via `requests`. user_id: The user's account ID number. Returns: A bool describing if the linter checks passed. This is used as the action's output value (a soft exit code). \"\"\" comments_url = base_url + f 'issues/ { Globals . EVENT_PAYLOAD [ \"number\" ] } /comments' remove_bot_comments ( comments_url , user_id ) payload = \"\" if Globals . OUTPUT : payload = json . dumps ({ \"body\" : Globals . OUTPUT }) logger . debug ( \"payload body: \\n %s \" , json . dumps ({ \"body\" : Globals . OUTPUT }, indent = 2 ) ) Globals . response_buffer = requests . post ( comments_url , headers = API_HEADERS , data = payload ) logger . info ( \"Got %d from POSTing comment\" , Globals . response_buffer . status_code ) log_response_msg () return bool ( payload )","title":"post_pr_comment()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.post_push_comment","text":"POST action's results for a push event. Parameters: Name Type Description Default base_url str The root of the url used to interact with the REST API via requests . required user_id int The user's account ID number. required Returns: Type Description bool A bool describing if the linter checks passed. This is used as the action's bool output value (a soft exit code). Source code in cpp_linter/run.py def post_push_comment ( base_url : str , user_id : int ) -> bool : \"\"\"POST action's results for a push event. Args: base_url: The root of the url used to interact with the REST API via `requests`. user_id: The user's account ID number. Returns: A bool describing if the linter checks passed. This is used as the action's output value (a soft exit code). \"\"\" comments_url = base_url + f \"commits/ { GITHUB_SHA } /comments\" remove_bot_comments ( comments_url , user_id ) if Globals . OUTPUT : # diff comments are not supported for push events (yet) payload = json . dumps ({ \"body\" : Globals . OUTPUT }) logger . debug ( \"payload body: \\n %s \" , json . dumps ({ \"body\" : Globals . OUTPUT })) Globals . response_buffer = requests . post ( comments_url , headers = API_HEADERS , data = payload ) logger . info ( \"Got %d response from POSTing comment\" , Globals . response_buffer . status_code ) log_response_msg () return bool ( Globals . OUTPUT )","title":"post_push_comment()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.post_results","text":"Post action's results using REST API. Parameters: Name Type Description Default use_diff_comments bool This flag enables making/updating comments in the PR's diff info. required user_id int The user's account ID number. Defaults to the generic bot's ID. 41898282 Source code in cpp_linter/run.py def post_results ( use_diff_comments : bool , user_id : int = 41898282 ): \"\"\"Post action's results using REST API. Args: use_diff_comments: This flag enables making/updating comments in the PR's diff info. user_id: The user's account ID number. Defaults to the generic bot's ID. \"\"\" if not GITHUB_TOKEN : logger . error ( \"The GITHUB_TOKEN is required!\" ) sys . exit ( set_exit_code ( 1 )) base_url = f \" { GITHUB_API_URL } /repos/ { GITHUB_REPOSITORY } /\" checks_passed = True if GITHUB_EVENT_NAME == \"pull_request\" : checks_passed = post_pr_comment ( base_url , user_id ) if use_diff_comments : checks_passed = post_diff_comments ( base_url , user_id ) elif GITHUB_EVENT_NAME == \"push\" : checks_passed = post_push_comment ( base_url , user_id ) set_exit_code ( 1 if checks_passed else 0 )","title":"post_results()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.run_clang_format","text":"Run clang-format on a certain file Parameters: Name Type Description Default filename str The name of the local file to run clang-format on. required file_obj Dict [ str , Any ] JSON info about the file. required version str The version of clang-format to run. required style str The clang-format style rules to adhere. Set this to 'file' to use the relative-most .clang-format configuration file. required lines_changed_only int A flag that forces focus on only changes in the event's diff info. required Source code in cpp_linter/run.py def run_clang_format ( filename : str , file_obj : Dict [ str , Any ], version : str , style : str , lines_changed_only : int , ) -> None : \"\"\"Run clang-format on a certain file Args: filename: The name of the local file to run clang-format on. file_obj: JSON info about the file. version: The version of clang-format to run. style: The clang-format style rules to adhere. Set this to 'file' to use the relative-most .clang-format configuration file. lines_changed_only: A flag that forces focus on only changes in the event's diff info. \"\"\" if not style : # if `style` == \"\" Path ( \"clang_format_output.xml\" ) . write_bytes ( b \"\" ) return # clear any previous output and exit cmds = [ assemble_version_exec ( \"clang-format\" , version ), f \"-style= { style } \" , \"--output-replacements-xml\" , ] if lines_changed_only : ranges = \"diff_chunks\" if lines_changed_only == 1 else \"lines_added\" for line_range in file_obj [ \"line_filter\" ][ ranges ]: cmds . append ( f \"--lines= { line_range [ 0 ] } : { line_range [ 1 ] } \" ) cmds . append ( PurePath ( filename ) . as_posix ()) logger . info ( 'Running \" %s \"' , \" \" . join ( cmds )) results = subprocess . run ( cmds , capture_output = True ) Path ( \"clang_format_output.xml\" ) . write_bytes ( results . stdout ) if results . returncode : logger . debug ( \" %s raised the following error(s): \\n %s \" , cmds [ 0 ], results . stderr . decode () )","title":"run_clang_format()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.run_clang_tidy","text":"Run clang-tidy on a certain file. Parameters: Name Type Description Default filename str The name of the local file to run clang-tidy on. required file_obj Dict [ str , Any ] JSON info about the file. required version str The version of clang-tidy to run. required checks str The str of comma-separated regulate expressions that describe the desired clang-tidy checks to be enabled/configured. required lines_changed_only int A flag that forces focus on only changes in the event's diff info. required Source code in cpp_linter/run.py def run_clang_tidy ( filename : str , file_obj : Dict [ str , Any ], version : str , checks : str , lines_changed_only : int , database : str , repo_root : str , ) -> None : \"\"\"Run clang-tidy on a certain file. Args: filename: The name of the local file to run clang-tidy on. file_obj: JSON info about the file. version: The version of clang-tidy to run. checks: The `str` of comma-separated regulate expressions that describe the desired clang-tidy checks to be enabled/configured. lines_changed_only: A flag that forces focus on only changes in the event's diff info. \"\"\" if checks == \"-*\" : # if all checks are disabled, then clang-tidy is skipped # clear the clang-tidy output file and exit function Path ( \"clang_tidy_report.txt\" ) . write_bytes ( b \"\" ) return filename = PurePath ( filename ) . as_posix () cmds = [ assemble_version_exec ( \"clang-tidy\" , version ), \"--export-fixes=clang_tidy_output.yml\" , ] if checks : cmds . append ( f \"-checks= { checks } \" ) if database : cmds . append ( \"-p\" ) if not PurePath ( database ) . is_absolute (): database = str ( Path ( RUNNER_WORKSPACE , repo_root , database ) . resolve ()) cmds . append ( database ) if lines_changed_only : ranges = \"diff_chunks\" if lines_changed_only == 1 else \"lines_added\" line_ranges = dict ( name = filename , lines = file_obj [ \"line_filter\" ][ ranges ]) logger . info ( \"line_filter = %s \" , json . dumps ([ line_ranges ])) cmds . append ( f \"--line-filter= { json . dumps ([ line_ranges ]) } \" ) cmds . append ( filename ) # clear yml file's content before running clang-tidy Path ( \"clang_tidy_output.yml\" ) . write_bytes ( b \"\" ) logger . info ( 'Running \" %s \"' , \" \" . join ( cmds )) results = subprocess . run ( cmds , capture_output = True ) Path ( \"clang_tidy_report.txt\" ) . write_bytes ( results . stdout ) logger . debug ( \"Output from clang-tidy: \\n %s \" , results . stdout . decode ()) if Path ( \"clang_tidy_output.yml\" ) . stat () . st_size : parse_tidy_suggestions_yml () # get clang-tidy fixes from yml if results . stderr : logger . debug ( \"clang-tidy made the following summary: \\n %s \" , results . stderr . decode () )","title":"run_clang_tidy()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.set_exit_code","text":"Set the action's exit code. Parameters: Name Type Description Default override int The number to use when overriding the action's logic. None Returns: Type Description int The exit code that was used. If the override parameter was not passed, int then this value will describe (like a bool value) if any checks failed. Source code in cpp_linter/run.py def set_exit_code ( override : int = None ) -> int : \"\"\"Set the action's exit code. Args: override: The number to use when overriding the action's logic. Returns: The exit code that was used. If the `override` parameter was not passed, then this value will describe (like a bool value) if any checks failed. \"\"\" exit_code = override if override is not None else bool ( Globals . OUTPUT ) print ( f \"::set-output name=checks-failed:: { exit_code } \" ) return exit_code","title":"set_exit_code()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.start_log_group","text":"Begin a collapsable group of log statements. Parameters: Name Type Description Default name str The name of the collapsable group required Source code in cpp_linter/run.py def start_log_group ( name : str ) -> None : \"\"\"Begin a collapsable group of log statements. Args: name: The name of the collapsable group \"\"\" log_commander . fatal ( \"::group:: %s \" , name )","title":"start_log_group()"},{"location":"API%20Reference/cpp_linter.run/#cpp_linter.run.verify_files_are_present","text":"Download the files if not present. Hint This function assumes the working directory is the root of the invoking repository. If files are not found, then they are downloaded to the working directory. This is bad for files with the same name from different folders. Source code in cpp_linter/run.py def verify_files_are_present () -> None : \"\"\"Download the files if not present. !!! hint This function assumes the working directory is the root of the invoking repository. If files are not found, then they are downloaded to the working directory. This is bad for files with the same name from different folders. \"\"\" for file in Globals . FILES : file_name = Path ( file [ \"filename\" ]) if not file_name . exists (): logger . warning ( \"Could not find %s ! Did you checkout the repo?\" , file_name ) logger . info ( \"Downloading file from url: %s \" , file [ \"raw_url\" ]) Globals . response_buffer = requests . get ( file [ \"raw_url\" ]) # retain the repo's original structure Path . mkdir ( file_name . parent , parents = True , exist_ok = True ) file_name . write_text ( Globals . response_buffer . text , encoding = \"utf-8\" )","title":"verify_files_are_present()"},{"location":"API%20Reference/cpp_linter.thread_comments/","text":"thread_comments module \u00b6 A module to house the various functions for traversing/adjusting comments aggregate_format_advice ( lines_changed_only : int ) -> List [ Dict [ str , Any ]] \u00b6 Aggregate a list of json contents representing advice from clang-format suggestions. Source code in cpp_linter/thread_comments.py def aggregate_format_advice ( lines_changed_only : int ) -> List [ Dict [ str , Any ]]: \"\"\"Aggregate a list of json contents representing advice from clang-format suggestions.\"\"\" results = [] for fmt_advice , file in zip ( GlobalParser . format_advice , Globals . FILES ): # get original code filename = Path ( file [ \"filename\" ]) # the list of lines from the src file lines = filename . read_text ( encoding = \"utf-8\" ) . splitlines () # aggregate clang-format suggestion line = \"\" # the line that concerns the fix for fixed_line in fmt_advice . replaced_lines : # clang-format can include advice that starts/ends outside the diff's domain ranges = range_of_changed_lines ( file , lines_changed_only ) if lines_changed_only and fixed_line . line not in ranges : continue # line is out of scope for diff, so skip this fix # assemble the suggestion body = \"## :scroll: clang-format advice \\n ```suggestion \\n \" line = lines [ fixed_line . line - 1 ] # logger.debug(\"%d >>> %s\", fixed_line.line, line[:-1]) for fix_index , line_fix in enumerate ( fixed_line . replacements ): # logger.debug( # \"%s >>> %s\", repr(line_fix), line_fix.text.encode(\"utf-8\") # ) if fix_index : last_fix = fixed_line . replacements [ fix_index - 1 ] body += line [ last_fix . cols + last_fix . null_len - 1 : line_fix . cols - 1 ] body += line_fix . text else : body += line [: line_fix . cols - 1 ] + line_fix . text # complete suggestion with original src code and closing md fence last_fix = fixed_line . replacements [ - 1 ] body += line [ last_fix . cols + last_fix . null_len - 1 : - 1 ] + \" \\n ```\" # logger.debug(\"body <<< %s\", body) # create a suggestion from clang-format advice results . append ( dict ( body = body , commit_id = GITHUB_SHA , line = fixed_line . line , path = fmt_advice . filename , side = \"RIGHT\" , ) ) return results aggregate_tidy_advice ( lines_changed_only : int ) -> List [ Dict [ str , Any ]] \u00b6 Aggregate a list of json contents representing advice from clang-tidy suggestions. Source code in cpp_linter/thread_comments.py def aggregate_tidy_advice ( lines_changed_only : int ) -> List [ Dict [ str , Any ]]: \"\"\"Aggregate a list of json contents representing advice from clang-tidy suggestions.\"\"\" results = [] for fixit , file in zip ( GlobalParser . tidy_advice , Globals . FILES ): for diag in fixit . diagnostics : ranges = range_of_changed_lines ( file , lines_changed_only ) if lines_changed_only and diag . line not in ranges : continue # base body of comment body = \"<!-- cpp linter action --> \\n ## :speech_balloon: Clang-tidy \\n **\" body += diag . name + \"** \\n >\" + diag . message # get original code filename = Path ( cast ( str , file [ \"filename\" ])) # the list of lines in a file lines = filename . read_text ( encoding = \"utf-8\" ) . splitlines () # aggregate clang-tidy advice suggestion = \" \\n ```suggestion \\n \" is_multiline_fix = False fix_lines : List [ int ] = [] # a list of line numbers for the suggested fixes line = \"\" # the line that concerns the fix/comment for i , tidy_fix in enumerate ( diag . replacements ): line = lines [ tidy_fix . line - 1 ] if not fix_lines : fix_lines . append ( tidy_fix . line ) elif tidy_fix . line not in fix_lines : is_multiline_fix = True break if i : # if this isn't the first tidy_fix for the same line last_fix = diag . replacements [ i - 1 ] suggestion += ( line [ last_fix . cols + last_fix . null_len - 1 : tidy_fix . cols - 1 ] + tidy_fix . text . decode () ) else : suggestion += line [: tidy_fix . cols - 1 ] + tidy_fix . text . decode () if not is_multiline_fix and diag . replacements : # complete suggestion with original src code and closing md fence last_fix = diag . replacements [ len ( diag . replacements ) - 1 ] suggestion += line [ last_fix . cols + last_fix . null_len - 1 : - 1 ] + \" \\n ```\" body += suggestion results . append ( dict ( body = body , commit_id = GITHUB_SHA , line = diag . line , path = fixit . filename , side = \"RIGHT\" , ) ) return results concatenate_comments ( tidy_advice : list , format_advice : list ) -> List [ Dict [ str , Union [ str , int ]]] \u00b6 Concatenate comments made to the same line of the same file. Source code in cpp_linter/thread_comments.py def concatenate_comments ( tidy_advice : list , format_advice : list ) -> List [ Dict [ str , Union [ str , int ]]]: \"\"\"Concatenate comments made to the same line of the same file.\"\"\" # traverse comments from clang-format for index , comment_body in enumerate ( format_advice ): # check for comments from clang-tidy on the same line comment_index = None for i , payload in enumerate ( tidy_advice ): if ( payload [ \"line\" ] == comment_body [ \"line\" ] and payload [ \"path\" ] == comment_body [ \"path\" ] ): comment_index = i # mark this comment for concatenation break if comment_index is not None : # append clang-format advice to clang-tidy output/suggestion tidy_advice [ comment_index ][ \"body\" ] += \" \\n \" + comment_body [ \"body\" ] del format_advice [ index ] # remove duplicate comment return tidy_advice + format_advice find_review ( reviews : dict , user_id : int ) -> Optional [ int ] \u00b6 Find a review created by a certain user ID. Parameters: Name Type Description Default reviews dict the JSON object fetched via GIT REST API. required user_id int The user account's ID number required Returns: Type Description Optional [ int ] An ID that corresponds to the specified user_id . Source code in cpp_linter/thread_comments.py def find_review ( reviews : dict , user_id : int ) -> Optional [ int ]: \"\"\"Find a review created by a certain user ID. Args: reviews: the JSON object fetched via GIT REST API. user_id: The user account's ID number Returns: An ID that corresponds to the specified `user_id`. \"\"\" review_id = None for review in reviews : if int ( review [ \"user\" ][ \"id\" ]) == user_id and review [ \"body\" ] . startswith ( \"<!-- cpp linter action -->\" ): review_id = int ( review [ \"id\" ]) break # there will only be 1 review from this action, so break when found logger . info ( \" review_id: %d \" , review_id ) return review_id get_review_id ( reviews_url : str , user_id : int ) -> Optional [ int ] \u00b6 Dismiss all stale reviews (only the ones made by our bot). Parameters: Name Type Description Default reviews_url str The URL used to fetch the review comments. required user_id int The user's account id number. required Returns: Type Description Optional [ int ] The ID number of the review created by the action's generic bot. Source code in cpp_linter/thread_comments.py def get_review_id ( reviews_url : str , user_id : int ) -> Optional [ int ]: \"\"\"Dismiss all stale reviews (only the ones made by our bot). Args: reviews_url: The URL used to fetch the review comments. user_id: The user's account id number. Returns: The ID number of the review created by the action's generic bot. \"\"\" logger . info ( \" review_url: %s \" , reviews_url ) Globals . response_buffer = requests . get ( reviews_url ) review_id = find_review ( json . loads ( Globals . response_buffer . text ), user_id ) if review_id is None : # create a PR review Globals . response_buffer = requests . post ( reviews_url , headers = API_HEADERS , data = json . dumps ( { \"body\" : \"<!-- cpp linter action --> \\n \" \"CPP Linter Action found no problems\" , \"event\" : \"COMMENTED\" , } ), ) logger . info ( \"Got %d from POSTing new(/temp) PR review\" , Globals . response_buffer . status_code , ) Globals . response_buffer = requests . get ( reviews_url ) if Globals . response_buffer . status_code != 200 and log_response_msg (): raise RuntimeError ( \"could not create a review for comments\" ) reviews = json . loads ( Globals . response_buffer . text ) reviews . reverse () # traverse the list in reverse review_id = find_review ( reviews , user_id ) return review_id list_diff_comments ( lines_changed_only : int ) -> List [ Dict [ str , Union [ str , int ]]] \u00b6 Aggregate list of comments for use in the event's diff. This function assumes that the CLI option --lines_changed_only is set to True. Returns: Type Description List [ Dict [ str , Union [ str , int ]]] A list of comments (each element as json content). Source code in cpp_linter/thread_comments.py def list_diff_comments ( lines_changed_only : int ) -> List [ Dict [ str , Union [ str , int ]]]: \"\"\"Aggregate list of comments for use in the event's diff. This function assumes that the CLI option `--lines_changed_only` is set to True. Returns: A list of comments (each element as json content). \"\"\" return concatenate_comments ( aggregate_tidy_advice ( lines_changed_only ), aggregate_format_advice ( lines_changed_only ), ) remove_bot_comments ( comments_url : str , user_id : int ) \u00b6 Traverse the list of comments made by a specific user and remove all. Parameters: Name Type Description Default comments_url str The URL used to fetch the comments. required user_id int The user's account id number. required Source code in cpp_linter/thread_comments.py def remove_bot_comments ( comments_url : str , user_id : int ): \"\"\"Traverse the list of comments made by a specific user and remove all. Args: comments_url: The URL used to fetch the comments. user_id: The user's account id number. \"\"\" logger . info ( \"comments_url: %s \" , comments_url ) Globals . response_buffer = requests . get ( comments_url ) if not log_response_msg (): return # error getting comments for the thread; stop here comments = Globals . response_buffer . json () for comment in comments : # only search for comments from the user's ID and # whose comment body begins with a specific html comment if ( int ( comment [ \"user\" ][ \"id\" ]) == user_id # the specific html comment is our action's name and comment [ \"body\" ] . startswith ( \"<!-- cpp linter action -->\" ) ): # remove other outdated comments but don't remove the last comment Globals . response_buffer = requests . delete ( comment [ \"url\" ], headers = API_HEADERS , ) logger . info ( \"Got %d from DELETE %s \" , Globals . response_buffer . status_code , comment [ \"url\" ][ comment [ \"url\" ] . find ( \".com\" ) + 4 :], ) log_response_msg () logger . debug ( \"comment id %d from user %s ( %d )\" , comment [ \"id\" ], comment [ \"user\" ][ \"login\" ], comment [ \"user\" ][ \"id\" ], ) with open ( \"comments.json\" , \"w\" , encoding = \"utf-8\" ) as json_comments : json . dump ( comments , json_comments , indent = 4 )","title":"thread_comments module"},{"location":"API%20Reference/cpp_linter.thread_comments/#thread_comments-module","text":"A module to house the various functions for traversing/adjusting comments","title":"thread_comments module"},{"location":"API%20Reference/cpp_linter.thread_comments/#cpp_linter.thread_comments.aggregate_format_advice","text":"Aggregate a list of json contents representing advice from clang-format suggestions. Source code in cpp_linter/thread_comments.py def aggregate_format_advice ( lines_changed_only : int ) -> List [ Dict [ str , Any ]]: \"\"\"Aggregate a list of json contents representing advice from clang-format suggestions.\"\"\" results = [] for fmt_advice , file in zip ( GlobalParser . format_advice , Globals . FILES ): # get original code filename = Path ( file [ \"filename\" ]) # the list of lines from the src file lines = filename . read_text ( encoding = \"utf-8\" ) . splitlines () # aggregate clang-format suggestion line = \"\" # the line that concerns the fix for fixed_line in fmt_advice . replaced_lines : # clang-format can include advice that starts/ends outside the diff's domain ranges = range_of_changed_lines ( file , lines_changed_only ) if lines_changed_only and fixed_line . line not in ranges : continue # line is out of scope for diff, so skip this fix # assemble the suggestion body = \"## :scroll: clang-format advice \\n ```suggestion \\n \" line = lines [ fixed_line . line - 1 ] # logger.debug(\"%d >>> %s\", fixed_line.line, line[:-1]) for fix_index , line_fix in enumerate ( fixed_line . replacements ): # logger.debug( # \"%s >>> %s\", repr(line_fix), line_fix.text.encode(\"utf-8\") # ) if fix_index : last_fix = fixed_line . replacements [ fix_index - 1 ] body += line [ last_fix . cols + last_fix . null_len - 1 : line_fix . cols - 1 ] body += line_fix . text else : body += line [: line_fix . cols - 1 ] + line_fix . text # complete suggestion with original src code and closing md fence last_fix = fixed_line . replacements [ - 1 ] body += line [ last_fix . cols + last_fix . null_len - 1 : - 1 ] + \" \\n ```\" # logger.debug(\"body <<< %s\", body) # create a suggestion from clang-format advice results . append ( dict ( body = body , commit_id = GITHUB_SHA , line = fixed_line . line , path = fmt_advice . filename , side = \"RIGHT\" , ) ) return results","title":"aggregate_format_advice()"},{"location":"API%20Reference/cpp_linter.thread_comments/#cpp_linter.thread_comments.aggregate_tidy_advice","text":"Aggregate a list of json contents representing advice from clang-tidy suggestions. Source code in cpp_linter/thread_comments.py def aggregate_tidy_advice ( lines_changed_only : int ) -> List [ Dict [ str , Any ]]: \"\"\"Aggregate a list of json contents representing advice from clang-tidy suggestions.\"\"\" results = [] for fixit , file in zip ( GlobalParser . tidy_advice , Globals . FILES ): for diag in fixit . diagnostics : ranges = range_of_changed_lines ( file , lines_changed_only ) if lines_changed_only and diag . line not in ranges : continue # base body of comment body = \"<!-- cpp linter action --> \\n ## :speech_balloon: Clang-tidy \\n **\" body += diag . name + \"** \\n >\" + diag . message # get original code filename = Path ( cast ( str , file [ \"filename\" ])) # the list of lines in a file lines = filename . read_text ( encoding = \"utf-8\" ) . splitlines () # aggregate clang-tidy advice suggestion = \" \\n ```suggestion \\n \" is_multiline_fix = False fix_lines : List [ int ] = [] # a list of line numbers for the suggested fixes line = \"\" # the line that concerns the fix/comment for i , tidy_fix in enumerate ( diag . replacements ): line = lines [ tidy_fix . line - 1 ] if not fix_lines : fix_lines . append ( tidy_fix . line ) elif tidy_fix . line not in fix_lines : is_multiline_fix = True break if i : # if this isn't the first tidy_fix for the same line last_fix = diag . replacements [ i - 1 ] suggestion += ( line [ last_fix . cols + last_fix . null_len - 1 : tidy_fix . cols - 1 ] + tidy_fix . text . decode () ) else : suggestion += line [: tidy_fix . cols - 1 ] + tidy_fix . text . decode () if not is_multiline_fix and diag . replacements : # complete suggestion with original src code and closing md fence last_fix = diag . replacements [ len ( diag . replacements ) - 1 ] suggestion += line [ last_fix . cols + last_fix . null_len - 1 : - 1 ] + \" \\n ```\" body += suggestion results . append ( dict ( body = body , commit_id = GITHUB_SHA , line = diag . line , path = fixit . filename , side = \"RIGHT\" , ) ) return results","title":"aggregate_tidy_advice()"},{"location":"API%20Reference/cpp_linter.thread_comments/#cpp_linter.thread_comments.concatenate_comments","text":"Concatenate comments made to the same line of the same file. Source code in cpp_linter/thread_comments.py def concatenate_comments ( tidy_advice : list , format_advice : list ) -> List [ Dict [ str , Union [ str , int ]]]: \"\"\"Concatenate comments made to the same line of the same file.\"\"\" # traverse comments from clang-format for index , comment_body in enumerate ( format_advice ): # check for comments from clang-tidy on the same line comment_index = None for i , payload in enumerate ( tidy_advice ): if ( payload [ \"line\" ] == comment_body [ \"line\" ] and payload [ \"path\" ] == comment_body [ \"path\" ] ): comment_index = i # mark this comment for concatenation break if comment_index is not None : # append clang-format advice to clang-tidy output/suggestion tidy_advice [ comment_index ][ \"body\" ] += \" \\n \" + comment_body [ \"body\" ] del format_advice [ index ] # remove duplicate comment return tidy_advice + format_advice","title":"concatenate_comments()"},{"location":"API%20Reference/cpp_linter.thread_comments/#cpp_linter.thread_comments.find_review","text":"Find a review created by a certain user ID. Parameters: Name Type Description Default reviews dict the JSON object fetched via GIT REST API. required user_id int The user account's ID number required Returns: Type Description Optional [ int ] An ID that corresponds to the specified user_id . Source code in cpp_linter/thread_comments.py def find_review ( reviews : dict , user_id : int ) -> Optional [ int ]: \"\"\"Find a review created by a certain user ID. Args: reviews: the JSON object fetched via GIT REST API. user_id: The user account's ID number Returns: An ID that corresponds to the specified `user_id`. \"\"\" review_id = None for review in reviews : if int ( review [ \"user\" ][ \"id\" ]) == user_id and review [ \"body\" ] . startswith ( \"<!-- cpp linter action -->\" ): review_id = int ( review [ \"id\" ]) break # there will only be 1 review from this action, so break when found logger . info ( \" review_id: %d \" , review_id ) return review_id","title":"find_review()"},{"location":"API%20Reference/cpp_linter.thread_comments/#cpp_linter.thread_comments.get_review_id","text":"Dismiss all stale reviews (only the ones made by our bot). Parameters: Name Type Description Default reviews_url str The URL used to fetch the review comments. required user_id int The user's account id number. required Returns: Type Description Optional [ int ] The ID number of the review created by the action's generic bot. Source code in cpp_linter/thread_comments.py def get_review_id ( reviews_url : str , user_id : int ) -> Optional [ int ]: \"\"\"Dismiss all stale reviews (only the ones made by our bot). Args: reviews_url: The URL used to fetch the review comments. user_id: The user's account id number. Returns: The ID number of the review created by the action's generic bot. \"\"\" logger . info ( \" review_url: %s \" , reviews_url ) Globals . response_buffer = requests . get ( reviews_url ) review_id = find_review ( json . loads ( Globals . response_buffer . text ), user_id ) if review_id is None : # create a PR review Globals . response_buffer = requests . post ( reviews_url , headers = API_HEADERS , data = json . dumps ( { \"body\" : \"<!-- cpp linter action --> \\n \" \"CPP Linter Action found no problems\" , \"event\" : \"COMMENTED\" , } ), ) logger . info ( \"Got %d from POSTing new(/temp) PR review\" , Globals . response_buffer . status_code , ) Globals . response_buffer = requests . get ( reviews_url ) if Globals . response_buffer . status_code != 200 and log_response_msg (): raise RuntimeError ( \"could not create a review for comments\" ) reviews = json . loads ( Globals . response_buffer . text ) reviews . reverse () # traverse the list in reverse review_id = find_review ( reviews , user_id ) return review_id","title":"get_review_id()"},{"location":"API%20Reference/cpp_linter.thread_comments/#cpp_linter.thread_comments.list_diff_comments","text":"Aggregate list of comments for use in the event's diff. This function assumes that the CLI option --lines_changed_only is set to True. Returns: Type Description List [ Dict [ str , Union [ str , int ]]] A list of comments (each element as json content). Source code in cpp_linter/thread_comments.py def list_diff_comments ( lines_changed_only : int ) -> List [ Dict [ str , Union [ str , int ]]]: \"\"\"Aggregate list of comments for use in the event's diff. This function assumes that the CLI option `--lines_changed_only` is set to True. Returns: A list of comments (each element as json content). \"\"\" return concatenate_comments ( aggregate_tidy_advice ( lines_changed_only ), aggregate_format_advice ( lines_changed_only ), )","title":"list_diff_comments()"},{"location":"API%20Reference/cpp_linter.thread_comments/#cpp_linter.thread_comments.remove_bot_comments","text":"Traverse the list of comments made by a specific user and remove all. Parameters: Name Type Description Default comments_url str The URL used to fetch the comments. required user_id int The user's account id number. required Source code in cpp_linter/thread_comments.py def remove_bot_comments ( comments_url : str , user_id : int ): \"\"\"Traverse the list of comments made by a specific user and remove all. Args: comments_url: The URL used to fetch the comments. user_id: The user's account id number. \"\"\" logger . info ( \"comments_url: %s \" , comments_url ) Globals . response_buffer = requests . get ( comments_url ) if not log_response_msg (): return # error getting comments for the thread; stop here comments = Globals . response_buffer . json () for comment in comments : # only search for comments from the user's ID and # whose comment body begins with a specific html comment if ( int ( comment [ \"user\" ][ \"id\" ]) == user_id # the specific html comment is our action's name and comment [ \"body\" ] . startswith ( \"<!-- cpp linter action -->\" ) ): # remove other outdated comments but don't remove the last comment Globals . response_buffer = requests . delete ( comment [ \"url\" ], headers = API_HEADERS , ) logger . info ( \"Got %d from DELETE %s \" , Globals . response_buffer . status_code , comment [ \"url\" ][ comment [ \"url\" ] . find ( \".com\" ) + 4 :], ) log_response_msg () logger . debug ( \"comment id %d from user %s ( %d )\" , comment [ \"id\" ], comment [ \"user\" ][ \"login\" ], comment [ \"user\" ][ \"id\" ], ) with open ( \"comments.json\" , \"w\" , encoding = \"utf-8\" ) as json_comments : json . dump ( comments , json_comments , indent = 4 )","title":"remove_bot_comments()"}]}